<html xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcq="http://purl.org/dc/qualifiers/1.0/" xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:fn="http://www.w3.org/2005/xpath-functions"><head>
<meta content="text/html; charset=UTF-16" http-equiv="Content-Type">
<title>Google JavaScript Style Guide</title>

<link rel="shortcut icon" type="image/x-icon" href="http://www.google.com/favicon.ico">
     <style>
body {
  background-color: #fff;
  color: #333;
  font-family: sans-serif;
  font-size: 10pt;
  margin-right: 100px;
  margin-left: 100px;
}

h1, h2, h3, h4, h5, h6, .toc_title {
  color: #06c;
  margin-top: 2em;
  margin-bottom: 1em;
}

h1 {
  text-align: center;
  font-size: 18pt;
}

h2, .toc_title {
  font-weight: bold;
  font-size: 12pt;
  margin-left: -40px;
}

h3, h4, h5, h6 {
  font-size: 10pt;
  margin-left: -20px;
}

.toc_category, .toc_stylepoint {
  font-size: 10pt;
  padding-top: .3em;
  padding-bottom: .3em;
}

table {
  border-collapse: collapse;
}

td, th {
  border: 1px solid #ccc;
  padding: 2px 12px;
  font-size: 10pt;
}

.toc td, .toc th {
  border-width: 1px 5px;
}

code, samp, var {
  color: #060;
}

pre {
  font-size: 10pt;
  display: block;
  color: #060;
  background-color: #f8fff8;
  border-color: #f0fff0;
  border-style: solid;
  border-top-width: 1px;
  border-bottom-width: 1px;
  border-right-width: 1px;
  border-left-width: 5px;
  padding-left: 12px;
  padding-right: 12px;
  padding-top: 4px;
  padding-bottom: 4px;
}

pre.badcode {
  color: #c00;
  background-color: #fff8f8;
  border-color: #fff0f0;
}

.showhide_button {
  float: left;
  cursor: pointer;
  border-width: 1px;
  border-style: solid;
  border-color: #ddd #aaa #aaa #ddd;
  padding: 0 3px 1px;
  margin: 0 4px 8px 0;
  border-radius: 3px;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
}

.link_button {
  float: left;
  display: none;
  background-color: #f8f8ff;
  border-color: #f0f0ff;
  border-style: solid;
  border-width: 1px;
  font-size: 75%;
  margin-top: 0;
  margin-left: -50px;
  padding: 4px;
  border-radius: 3px;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
}

address {
  text-align: right;
}

hr {
  margin-top: 3.5em;
  border-width: 1px;
  color: #fff;
}

.stylepoint_section {
  display: block;
  margin-bottom: 1em;
  color: #5588ff;
  font-family: sans-serif;
  font-size: 90%;
  font-weight: bold;
  margin-left: -2%;
}

.stylepoint_subsection {
  color: #667799;
  font-family: sans-serif;
  font-size: 90%;
  font-weight: bold;
  margin-left: -1%;
}

.stylepoint_subsubsection {
  color: #667799;
  font-family: sans-serif;
  font-size: 80%;
  font-weight: bold;
  margin-left: 0;
}

.revision {
  text-align: right;
}

     </style>
<script language="javascript" type="text/javascript">

                function GetElementsByName(name) {
                  // Workaround a bug on old versions of opera.
                  if (document.getElementsByName) {
                    return document.getElementsByName(name);
                  } else {
                    return [document.getElementById(name)];
                  }
                }

                /**
                 * @param {string} namePrefix The prefix of the body name.
                 * @param {function(boolean): boolean} getVisibility Computes the new
                 *     visibility state, given the current one.
                 */
                function ChangeVisibility(namePrefix, getVisibility) {
                  var bodyName = namePrefix + '__body';
                  var buttonName = namePrefix + '__button';
                  var bodyElements = GetElementsByName(bodyName);
                  var linkElement = GetElementsByName('link-' + buttonName)[0];
                  if (bodyElements.length != 1) {
                    throw Error('ShowHideByName() got the wrong number of bodyElements:  ' + 
                        bodyElements.length);
                  } else {
                    var bodyElement = bodyElements[0];
                    var buttonElement = GetElementsByName(buttonName)[0];
                    var isVisible = bodyElement.style.display != "none";
                    if (getVisibility(isVisible)) {
                      bodyElement.style.display = "inline";
                      linkElement.style.display = "block";
                      buttonElement.innerHTML = '▽';
                    } else {
                      bodyElement.style.display = "none";
                      linkElement.style.display = "none";
                      buttonElement.innerHTML = '▶';
                    }
                  }
                }

                function ShowHideByName(namePrefix) {
                  ChangeVisibility(namePrefix, function(old) { return !old; });
                }

                function ShowByName(namePrefix) {
                  ChangeVisibility(namePrefix, function() { return true; });
                }

                function ShowHideAll() {
                  var allButton = GetElementsByName("show_hide_all_button")[0];
                  if (allButton.innerHTML == '▽') {
                    allButton.innerHTML = '▶';
                    SetHiddenState(document.getElementsByTagName("body")[0].childNodes, "none", '▶');
                  } else {
                    allButton.innerHTML = '▽';
                    SetHiddenState(document.getElementsByTagName("body")[0].childNodes, "inline", '▽');
                  }
                }

                // Recursively sets state of all children
                // of a particular node.
                function SetHiddenState(root, newState, newButton) {
                  for (var i = 0; i != root.length; i++) {
                    SetHiddenState(root[i].childNodes, newState, newButton);
                    if (root[i].className == 'showhide_button')  {
                      root[i].innerHTML = newButton;
                    }
                    if (root[i].className == 'stylepoint_body' ||
                        root[i].className == 'link_button')  {
                      root[i].style.display = newState;
                    }
                  }
                }


                function EndsWith(str, suffix) {
                  var l = str.length - suffix.length;
                  return l >= 0 && str.indexOf(suffix, l) == l;
                }

                function RefreshVisibilityFromHashParam() {
                  var hashRegexp = new RegExp('#([^&#]*)$');
                  var hashMatch = hashRegexp.exec(window.location.href);
                  var anchor = hashMatch && GetElementsByName(hashMatch[1])[0];
                  var node = anchor;
                  var suffix = '__body';
                  while (node) {
                    var id = node.id;
                    var matched = id && EndsWith(id, suffix);
                    if (matched) {
                      var len = id.length - suffix.length;
                      ShowByName(matched.substring(0, len));
                      if (anchor.scrollIntoView) {
                        anchor.scrollIntoView();
                      }
                      
                      return;
                    }
                    node = node.parentNode;
                  }
                }

                window.onhashchange = RefreshVisibilityFromHashParam;

                window.onload = function() {
                  // if the URL contains "?showall=y", expand the details of all children
                  var showHideAllRegex = new RegExp("[\\?&](showall)=([^&#]*)");
                  var showHideAllValue = showHideAllRegex.exec(window.location.href);
                  if (showHideAllValue != null) {
                    if (showHideAllValue[2] == "y") {
                      SetHiddenState(document.getElementsByTagName("body")[0].childNodes, 
                          "inline", '▽');
                    } else {
                      SetHiddenState(document.getElementsByTagName("body")[0].childNodes, 
                          "none", '▶');
                    }
                  }
                  var showOneRegex = new RegExp("[\\?&](showone)=([^&#]*)");
                  var showOneValue = showOneRegex.exec(window.location.href);
                  if (showOneValue) {
                    ShowHideByName(showOneValue[2]);
                  }


                  RefreshVisibilityFromHashParam();
                }
              </script>
</head><body>
<h1>Google JavaScript代码风格指南</h1>
  <p class="revision">
    
    修正版本 2.28
  </p>
  
  <address>
    Aaron Whyte<br>
    Bob Jervis<br>
    Dan Pupius<br>
    Eric Arvidsson<br>
    Fritz Schneider<br>
    Robby Walker<br>
  </address>
  <div style="margin-left: 50%; font-size: 75%;">
            <p>
                每个风格点都有一个展开/收起按钮以便你可以得到更多的信息:<span style="margin-left: 0; float: none" class="showhide_button">▶</span>.
                你可以将全部展开或收起:
            </p>
            <div style=" font-size: larger; margin-left: +2em;">
                <span id="show_hide_all_button" name="show_hide_all_button" onclick="javascript:ShowHideAll()" style="font-size: 180%; float: none" class="showhide_button">▶</span>
                全部展开/全部收起
            </div>
        </div>
<div class="toc">
<div class="toc_title">内容树
</div>
<table>
<tbody><tr valign="top">
<td>
<div class="toc_category"><a href="#JavaScript_Language_Rules">JavaScript语言规范</a></div>
</td><td>
<div class="toc_stylepoint"><span style="padding-right: 1em; white-space: nowrap;"><a href="#var">变量</a></span> <span style="padding-right: 1em; white-space: nowrap;"><a href="#Constants">常量</a></span> <span style="padding-right: 1em; white-space: nowrap;"><a href="#Semicolons">分号</a></span> <span style="padding-right: 1em; white-space: nowrap;"><a href="#Nested_functions">嵌套函数</a></span> <span style="padding-right: 1em; white-space: nowrap;"><a href="#Function_Declarations_Within_Blocks">块内函数声明</a></span> <span style="padding-right: 1em; white-space: nowrap;"><a href="#Exceptions">异常处理</a></span> <span style="padding-right: 1em; white-space: nowrap;"><a href="#Custom_exceptions">自定义异常</a></span> <span style="padding-right: 1em; white-space: nowrap;"><a href="#Standards_features">标准特性</a></span> <span style="padding-right: 1em; white-space: nowrap;"><a href="#Wrapper_objects_for_primitive_types">基本包装类型</a></span> <span style="padding-right: 1em; white-space: nowrap;"><a href="#Multi-level_prototype_hierarchies">多级原型结构</a></span> <span style="padding-right: 1em; white-space: nowrap;"><a href="#Method_definitions">方法定义</a></span> <span style="padding-right: 1em; white-space: nowrap;"><a href="#Closures">闭包</a></span> <span style="padding-right: 1em; white-space: nowrap;"><a href="#eval__">eval()</a></span> <span style="padding-right: 1em; white-space: nowrap;"><a href="#with___{}">with() {}</a></span> <span style="padding-right: 1em; white-space: nowrap;"><a href="#this">this</a></span> <span style="padding-right: 1em; white-space: nowrap;"><a href="#for-in_loop">for-in 循环</a></span> <span style="padding-right: 1em; white-space: nowrap;"><a href="#Associative_Arrays">关联数组</a></span> <span style="padding-right: 1em; white-space: nowrap;"><a href="#Multiline_string_literals">多行字符串字面量</a></span> <span style="padding-right: 1em; white-space: nowrap;"><a href="#Array_and_Object_literals">Array和Object字面量</a></span> <span style="padding-right: 1em; white-space: nowrap;"><a href="#Modifying_prototypes_of_builtin_objects">修改内置对象的原型</a></span> <span style="padding-right: 1em; white-space: nowrap;"><a href="#Internet_Explorer_s_Conditional_Comments">IE下的条件注释</a></span> </div>
</td>
</tr>
<tr valign="top">
<td>
<div class="toc_category"><a href="#JavaScript_Style_Rules">JavaScript代码风格规范</a></div>
</td><td>
<div class="toc_stylepoint"><span style="padding-right: 1em; white-space: nowrap;"><a href="#Naming">命名</a></span> <span style="padding-right: 1em; white-space: nowrap;"><a href="#Custom_toString___methods">自定义toString()方法</a></span> <span style="padding-right: 1em; white-space: nowrap;"><a href="#Deferred_initialization">延迟初始化</a></span> <span style="padding-right: 1em; white-space: nowrap;"><a href="#Explicit_scope">明确作用域</a></span> <span style="padding-right: 1em; white-space: nowrap;"><a href="#Code_formatting">代码格式化</a></span> <span style="padding-right: 1em; white-space: nowrap;"><a href="#Parentheses">括号</a></span> <span style="padding-right: 1em; white-space: nowrap;"><a href="#Strings">字符串</a></span> <span style="padding-right: 1em; white-space: nowrap;"><a href="#Visibility__private_and_protected_fields_">可见性（私有和受保护的字段）</a></span> <span style="padding-right: 1em; white-space: nowrap;"><a href="#JavaScript_Types">JavaScript 类型</a></span> <span style="padding-right: 1em; white-space: nowrap;"><a href="#Comments">注释</a></span> <span style="padding-right: 1em; white-space: nowrap;"><a href="#Inner_Classes_and_Enums">内部类和枚举</a></span> <span style="padding-right: 1em; white-space: nowrap;"><a href="#Compiling">编译压缩</a></span> <span style="padding-right: 1em; white-space: nowrap;"><a href="#Tips_and_Tricks">提示和技巧</a></span> </div>
</td>
</tr>
</tbody></table>
</div>
    
    <div>
<h2 id="Background" name="Background">背景</h2>
      <p title="我觉得JavaScript是一门令人愉悦的语言，什么？当然没有比看片愉悦！可是你能天天在办公区看片么？！">JavaScript是一门客户端脚本语言，Google经常用它来晒优越，本文档列出了一些在做JS项目时需要注意的地方。都是高富帅整理的，还望各位屌丝们有时间都好好看看多学学，别对这个世界太消极了！（译者注：所谓的客户端呢就是浏览器或本地软件环境，市面上所有的浏览器都支持JS，JS发展到现在统一WEB端再进军移动互联网后，相信在一段时间内都是不可被轻易替代的语言，所以有兴趣的同学们可以多关注一下）</p>
      
      
      
    </div>
  
  <div>
<h2 id="JavaScript_Language_Rules" name="JavaScript_Language_Rules">JavaScript语言规范</h2>
    

    

    <div>
<h3><a id="var" name="var">变量（var）</a></h3><span id="link-var__button" class="link_button" name="link-var__button" style="display: none; "><a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml?showone=var">原文</a></span><span id="var__button" class="showhide_button" onclick="javascript:ShowHideByName('var')" name="var__button">▶</span>
      <div style="display: inline;"><code><span class="Apple-style-span" style="color: rgb(51, 51, 51); font-family: sans-serif; ">每个变量声明都要加上</span>var<span class="Apple-style-span" style="color: rgb(51, 51, 51); font-family: sans-serif; ">关键字噢。</span></code></div><div>
<div style="display: none; " id="var__body" class="stylepoint_body" name="var__body">
        <p><span class="stylepoint_section">解释：</span>如果你不指定关键字<code>var</code>, 该变量就会暴露在全局作用域（window）中，这很可能会覆盖全局作用域中的同名变量，从而引发问题（另外GC也会因此而无法有效回收内存啊），所以务必用<code>var</code>声明变量。</p>
      </div>
</div>
    </div>

    <div>
<h3><a id="Constants" name="Constants">常量</a></h3><span id="link-Constants__button" class="link_button" name="link-Constants__button" style="display: none; "><a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml?showone=Constants">原文</a></span><span id="Constants__button" class="showhide_button" onclick="javascript:ShowHideByName('Constants')" name="Constants__button">▶</span>
      <div style="display: inline;">常量命名用类似<code>NAMES_LIKE_THIS</code>这样的形式。没事干了可以用<code>@const</code>来标记它是常量，但永远不要用<code>const</code>关键字来进行常量声明。</div><div>
<div style="display: none; " id="Constants__body" class="stylepoint_body" name="Constants__body">
        <p><span class="stylepoint_section">解释：</span>
          </p><p>对于基本类型的常量，命名简介解释一下作用就可以了。</p>
          <div>
<pre>/**
 * 一分钟有多少秒呀
 * @type {number}
 */
goog.example.SECONDS_IN_A_MINUTE = 60;</pre>
</div>
          <p>对于非基本类型，用<code>@const</code>注释一下会更明了。</p>
          <div>
<pre>/**
 * 已知单位所对应的秒数
 * @type {Object.&lt;number&gt;}
 * @const
 */
goog.example.SECONDS_TABLE = {
  minute: 60,
  hour: 60 * 60
  day: 60 * 60 * 24
}</pre>
</div>
          <p>这个标记主要是让编译器知道这变量是常量状态。</p>
          <p>至于关键词<code>const</code>，IE不解析啊会报错的，所以别用啦。</p>
        <p></p>
      </div>
</div>
    </div>

    <div>
<h3>分号</h3><span id="link-Semicolons__button" class="link_button" name="link-Semicolons__button" style="display: none; "><a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml?showone=Semicolons">原文</a></span><span id="Semicolons__button" class="showhide_button" onclick="javascript:ShowHideByName('Semicolons')" name="Semicolons__button">▶</span>
      每一语句的结尾都要加上分号噢。<br><div>
<div style="display: none; " id="Semicolons__body" class="stylepoint_body" name="Semicolons__body">
        <p>如果不加分号JS解释器也会按隐式分隔的标准去执行，但那样调试、压缩、合并的时候都很不方便。不要那样做嘛你可以做的更好的不是么。</p>
        <p>而且在某些情况下，不写分号可是很危险的：</p>
        <div>
<pre class="badcode">// 1.
MyClass.prototype.myMethod = function() {
  return 42;
}  // 这个缺德的没写分号

(function() {
  // 匿名函数的执行
})();


var x = {
  'i': 1,
  'j': 2
}  // 这个天杀的也没写分号

// 2. 在IE和FF的某些版本里试试（译者表示没试出来）
// 老子知道你永远也不会写这样2的代码的，但它真的会因为木有写分号而报错噢
[normalVersion, ffVersion][isIE]();


var THINGS_TO_EAT = [apples, oysters, sprayOnCheese]  // 这个屌丝木有写分号

// 3. conditional execution a la bash
-1 == resultOfOperation() || die();</pre>
</div>
        <p><font class="Apple-style-span" color="#667799"><span class="Apple-style-span" style="font-size: 12px;"><b>上段代码会发生什么事情？</b></span></font></p><ol>
            <li>会报错（<span class="Apple-style-span" style="color: rgb(255, 0, 0); font-family: Consolas, 'Lucida Console', monospace; font-size: 12px; line-height: 18px; ">number is not a function</span>）-第一个方法返回了42，因为没分号啊，后面就直接跟括号，所以第二个方法就很杯具的被当成一个参数传进来给42执行了（效果等同于"42(func)()"），可42并不是一个方法，报错。</li>
            <li>在运行时可能会报 '<span class="Apple-style-span" style="color: rgb(255, 0, 0); font-family: Consolas, 'Lucida Console', monospace; font-size: 12px; line-height: 18px; ">no such property in undefined</span>' 这样的错误，效果等同于是执行&nbsp;<code>x[ffVersion][isIE]()</code>。（译者木验证）</li>
            <li>如果&nbsp;<code>resultOfOperation()</code>&nbsp;返回非&nbsp;<code>NaN</code>&nbsp;那就会调用&nbsp;<code>die</code>&nbsp;方法，并导致&nbsp;<code>die()</code>&nbsp;执行后的返回结果会赋给&nbsp;<code>THINGS_TO_EAT</code>&nbsp;。</li>
          </ol>
        <p></p>
        <p><font class="Apple-style-span" color="#667799"><span class="Apple-style-span" style="font-size: 12px; "><b>为啥会这样呢？</b></span></font></p><p>JS语句以分号作为结束符使得JS解释器解析，如果省略分号，就会由JS解释器确定语句的结尾。尼玛，不是在很明确的情况下，它能确定么？上面几个例子里，都是在语句中声明了/函数/对象/数组，但闭括号（"}"或"]"）并不代表着结束。如果下一个语句开始是一个中缀或括号运算符，那JS就永远不会结束声明。</p>
          <p>这真的是很奇怪的事情噢亲，而且真的不知道还会出现什么奇怪的事情噢亲，所以确保你的语句有分号结束吧。</p><p>译者注：加上分号也会在某些情况下增进代码的性能，因为这样解析器就不必再花时间推测应该在哪里插入分号了（取自《Javascript高级程序设计》）</p>
        <p></p>
      </div>
</div>
    </div>

    <div>
<h3>嵌套函数</h3><span id="link-Nested_functions__button" class="link_button" name="link-Nested_functions__button" style="display: none; "><a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml?showone=Nested_functions">原文</a></span><span id="Nested_functions__button" class="showhide_button" onclick="javascript:ShowHideByName('Nested_functions')" name="Nested_functions__button">▶</span>
      可以使用，木有问题。<br><div>
<div style="display: none; " id="Nested_functions__body" class="stylepoint_body" name="Nested_functions__body">
        <p>嵌套函数非常有用，它可以重用而减少代码量，或防止一些辅助作用的方法暴露在外等优点，请随意把玩（叫破喉咙也不会有人来救它的）。</p>
      </div>
</div>
    </div>

    <div>
<h3>块内函数声明</h3><span id="link-Function_Declarations_Within_Blocks__button" class="link_button" name="link-Function_Declarations_Within_Blocks__button" style="display: none; "><a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml?showone=Function_Declarations_Within_Blocks">原文</a></span><span id="Function_Declarations_Within_Blocks__button" class="showhide_button" onclick="javascript:ShowHideByName('Function_Declarations_Within_Blocks')" name="Function_Declarations_Within_Blocks__button">▶</span>
      呀咩嗲。<br><div>
<div style="display: none; " id="Function_Declarations_Within_Blocks__body" class="stylepoint_body" name="Function_Declarations_Within_Blocks__body">
        <p>只有屌丝才这样做：</p>
        <div>
<pre class="badcode">if (x) {
  function foo() {}
}</pre>
</div>

        <p>虽然大多数JS引擎都支持块内声明函数，但它并不是 ECMAScript 标准的一部分（详见          <a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm">ECMA-262</a>, 第13条和第14条）。更糟糕的是各引擎对于块内函数声明的实现都不一样，和 EcmaScript 的建议相违背。 ECMAScript 只允许在根脚本语句或其他函数中进行函数声明，如果一定要用的话可以在块内用变量来定义函数：</p>
        <div>
<pre>if (x) {
  var foo = function() {}
}</pre>
</div>
      </div>
</div>
    </div>

    <div>
<h3>异常处理</h3><span id="link-Exceptions__button" class="link_button" name="link-Exceptions__button" style="display: none; "><a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml?showone=Exceptions">原文</a></span><span id="Exceptions__button" class="showhide_button" onclick="javascript:ShowHideByName('Exceptions')" name="Exceptions__button">▶</span>支持合理使用。<br><div>
<div style="display: none; " id="Exceptions__body" class="stylepoint_body" name="Exceptions__body">
        <p>不管谁写代码都不能百分百的说自己的程序木有异常的。所以，细心的检查代码是一方面，预先处理一些可能出现的异常也是有必要的（使用try-catch(e)），特别是正在做一些重要项目的时候（框架什么的）。</p><p>译者注：如果是预先就知道自己的代码会发生错误时，再使用try-catch语句就不合适了噢，而是应该预先对其进行检查，防止错误的出现（取自《JavaScript高级程序设计》）</p>
      </div>
</div>
    </div>

    <div>
<h3><a id="Custom_exceptions" name="Custom_exceptions">自定义异常</a></h3><span id="link-Custom_exceptions__button" class="link_button" name="link-Custom_exceptions__button" style="display: none; "><a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml?showone=Custom_exceptions">原文</a></span><span id="Custom_exceptions__button" class="showhide_button" onclick="javascript:ShowHideByName('Custom_exceptions')" name="Custom_exceptions__button">▶</span>支持合理使用。<br><div>
<div style="display: none; " id="Custom_exceptions__body" class="stylepoint_body" name="Custom_exceptions__body">
        <p>没有自定义异常抛出的情况下，代码运行可能会报一些原始的错误信息，但包含的内容和错误描述会因浏览器而不同却都不是特别明确，不易维护，No fashion！所以在感觉适当的时候可以使用自定义异常抛出（这里指的是throw，带有适当信息的自定义错误能够显著提升代码的可维护性）。</p>
      </div>
</div>
    </div>

    <div>
<h3>标准特性</h3><span id="link-Standards_features__button" class="link_button" name="link-Standards_features__button" style="display: none; "><a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml?showone=Standards_features">原文</a></span><span id="Standards_features__button" class="showhide_button" onclick="javascript:ShowHideByName('Standards_features')" name="Standards_features__button">▶</span>
      总是优越于非标准特性之上。<br><div>
<div style="display: none; " id="Standards_features__body" class="stylepoint_body" name="Standards_features__body">
        <p>为了获得最大的可移植性和兼容性，尽量依赖于标准方法。（比如使用&nbsp;<code>string.charAt(3)</code>&nbsp;而不是&nbsp;<code>string[3]</code>&nbsp;，再比如通过DOM原生方法去访问节点元素，而不是使用某框架封装好的获取方法或快捷引用）。</p>
      </div>
</div>
    </div>

    <div>
<h3>基本包装类型</h3><span id="link-Wrapper_objects_for_primitive_types__button" class="link_button" name="link-Wrapper_objects_for_primitive_types__button" style="display: none; "><a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml?showone=Wrapper_objects_for_primitive_types">原文</a></span><span id="Wrapper_objects_for_primitive_types__button" class="showhide_button" onclick="javascript:ShowHideByName('Wrapper_objects_for_primitive_types')" name="Wrapper_objects_for_primitive_types__button">▶</span>
      主动 new 基本包装类型（Boolean/Number/String）的人儿永远也成不了高富帅！<br><div>
<div style="display: none; " id="Wrapper_objects_for_primitive_types__body" class="stylepoint_body" name="Wrapper_objects_for_primitive_types__body">
        <p>木有必要去使用基本包装类型么就不要使用啦，而且它在以下这种情况下很危险：</p>
        <div>
<pre class="badcode">var x = new Boolean(false);
if (x) {
  alert('hi');  // 显示 hi。因为基本包装类型的实例调用typeof会返回"object"，对象么在判断时都会被转换为布尔值true。
}</pre>
</div>
        <p>所以，你懂得！就算不懂，也终有一天会懂的嘛！</p>
        <p>唉，可是还是有种情况是可以使用的嘛，比如类型转换：</p>
        <div>
<pre>var x = Boolean(0);
if (x) {
  alert('hi');  // 不会弹框显示 hi
}
typeof Boolean(0) == 'boolean';
typeof new Boolean(0) == 'object';</pre>
</div>
        <p>它对于&nbsp;<code>number</code>, <code>string</code>&nbsp;和&nbsp;<code>boolean&nbsp;</code>之间的类型转换很有帮助。</p>
      </div>
</div>
    </div>

    <div>
<h3>多级原型结构</h3><span id="link-Multi-level_prototype_hierarchies__button" class="link_button" name="link-Multi-level_prototype_hierarchies__button" style="display: none; "><a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml?showone=Multi-level_prototype_hierarchies">原文</a></span><span id="Multi-level_prototype_hierarchies__button" class="showhide_button" onclick="javascript:ShowHideByName('Multi-level_prototype_hierarchies')" name="Multi-level_prototype_hierarchies__button">▶</span>
      <div style="display: inline;">不是怎么推荐使用。</div><div>
<div style="display: none; " id="Multi-level_prototype_hierarchies__body" class="stylepoint_body" name="Multi-level_prototype_hierarchies__body">
        <p>多级原型结构指的是 JavaScript 实现继承。 比如自定义类D，并把自定义类B作为D的原型，那就是一个多级原型结构了。怎么说呢，结构越来越复杂了就越难维护。</p>

        <p>鉴于此，使用&nbsp;<a href="http://code.google.com/closure/library/">the Closure Library
</a>的&nbsp;<code>goog.inherits()</code>&nbsp;或许会是更好的选择。</p>
        <div>
<pre>function D() {
  goog.base(this)
}
goog.inherits(D, B);

D.prototype.method = function() {
  ...
};</pre>
</div>
      </div>
</div>
    </div>

    <div>
<h3><a id="Method_definitions" name="Method_definitions">方法定义</a></h3><span id="link-Method_definitions__button" class="link_button" name="link-Method_definitions__button" style="display: none; "><a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml?showone=Method_definitions">原文</a></span><span id="Method_definitions__button" class="showhide_button" onclick="javascript:ShowHideByName('Method_definitions')" name="Method_definitions__button">▶</span>
      <div style="display: inline;"><code>Foo.prototype.bar = function() { ... };</code></div>
      <div>
<div style="display: none; " id="Method_definitions__body" class="stylepoint_body" name="Method_definitions__body">
        <p>给原型对象的构造函数添加方法和属性有很多种方式，更倾向于使用以下这种风格：</p>
        <div>
<pre>Foo.prototype.bar = function() {
  /* ... */
};</pre>
</div>
      </div>
</div>
    </div>

    <div>
<h3><a id="Closures" name="Closures">闭包</a></h3><span id="link-Closures__button" class="link_button" name="link-Closures__button" style="display: none; "><a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml?showone=Closures">原文</a></span><span id="Closures__button" class="showhide_button" onclick="javascript:ShowHideByName('Closures')" name="Closures__button">▶</span>
      <div style="display: inline;">上古之大杀器，顺则飞龙在天，滥则亢龙有悔。</div><div>
<div style="display: none; " id="Closures__body" class="stylepoint_body" name="Closures__body">
        <p>很有用，却经常被忽略（哪里被忽略了基本哪次面试都有被问到这样的问题有木有！！！）。有耐心的去看看&nbsp;<a href="http://jibbering.com/faq/faq_notes/closures.html">a good description of how closures work</a>。</p>
        <p>有一件需要注意的事情，闭包会保持一个指向它封闭作用域的指针，所以在给DOM元素附加闭包时，很可能会产生循环引用，进一步的消耗内存，比如下面的代码：</p>
        <div>
<pre class="badcode">function foo(element, a, b) {
  element.onclick = function() { /* uses a and b */ };
}</pre>
</div>
        <p>即便这个闭包函数内部并没有使用&nbsp;<span class="Apple-style-span" style="color: rgb(0, 102, 0); font-family: monospace; ">element</span>，可它还是保持了对&nbsp;<code>element</code>,
          <code>a</code>&nbsp;和&nbsp;<code>b</code>&nbsp;的引用，而&nbsp;<code>element</code>&nbsp;也保持了对这闭包函数的引用，就导致了循环引用，无法被GC回收。如果遇到了这种情况，可以将代码优化一下：</p>
        <div>
<pre>function foo(element, a, b) {
  element.onclick = bar(a, b);
}

function bar(a, b) {
  return function() { /* uses a and b */ }
}</pre>
</div>
<p>译者注：由于IE9之前的版本对JScript对象和COM对象使用不同的垃圾收集例程，因此闭包在IE的这些版本中会导致如上问题。这个匿名函数作为element元素事件处理程序，形成闭包的状态就会保存对父层函数内活动对象的引用，只要匿名函数存在，element的引用数至少也是1，因此它所占用的内存就永远不会被回收。注意，闭包会引用包含函数的整个活动对象，即使闭包不直接引用element，包含函数的活动对象中也仍然会保存一个引用。因此，有必要把使用完的element变量设置为null，解除对DOM对象的引用，确保正常回收其占用的内存。（取自《Javascript高级程序设计》184P）</p>
      </div>
</div>
    </div>

    <div>
<h3><a id="eval__" name="eval__">eval()</a></h3><span id="link-eval____button" class="link_button" name="link-eval____button" style="display: none; "><a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml?showone=eval__">原文</a></span><span id="eval____button" class="showhide_button" onclick="javascript:ShowHideByName('eval__')" name="eval____button">▶</span>
      <div style="display: inline;">只用于反序列化。（反序列化的意思是从字节流中重构对象，这里指的应该是JSON字符串重构成对象，或是执行服务器返回的JS语句）</div><div>
<div style="display: none; " id="eval____body" class="stylepoint_body" name="eval____body">
        <p><code>eval()</code>&nbsp;很不稳定，会造成语义混乱，如果代码里还包含用户输入的话就更危险了，因为你无法确切得知用户会输入什么！难道就不能用更好更清晰更安全的方式去写你的代码么孩子？</p><p>然而&nbsp;<code>eval</code>&nbsp;很容易解析被序列化的对象，所以反序列化的任务还是可以交给它做的。（例如：解析RPC响应的时候）</p>
        <p>反序列化的过程就是将字节流转换成内存中的数据结构。例如，你可能会将对象输出到文件中：</p>
        <div>
<pre>users = [
  {
    name: 'Eric',
    id: 37824,
    email: 'jellyvore@myway.com'
  },
  {
    name: 'xtof',
    id: 31337,
    email: 'b4d455h4x0r@google.com'
  },
  ...
];</pre>
</div>
        <p>用&nbsp;<span class="Apple-style-span" style="color: rgb(0, 102, 0); font-family: monospace; ">eval</span>&nbsp;可以很简单的读取这些数据到内存中。</p>
        <p>同样，用&nbsp;<code>eval()</code>&nbsp;可以简单的解码RPC返回值。例如，你用&nbsp;<code>XMLHttpRequest</code>&nbsp;发出一个RPC请求，服务器端相应返回JavaScript代码：</p>
        <div>
<pre>var userOnline = false;
var user = 'nusrat';
var xmlhttp = new XMLHttpRequest();
xmlhttp.open('GET', 'http://chat.google.com/isUserOnline?user=' + user, false);
xmlhttp.send('');
// Server returns:
// userOnline = true;
if (xmlhttp.status == 200) {
  eval(xmlhttp.responseText);
}
// userOnline is now true.</pre>
</div>
      </div>
</div>
    </div>

    <div>
<h3><a id="with___{}" name="with___{}">with() {}</a></h3><span id="link-with___{}__button" class="link_button" name="link-with___{}__button" style="display: none; "><a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml?showone=with___{}">原文</a></span><span id="with___{}__button" class="showhide_button" onclick="javascript:ShowHideByName('with___{}')" name="with___{}__button">▶</span>
      别用。<br><div>
<div style="display: none; " id="with___{}__body" class="stylepoint_body" name="with___{}__body">
        <p>使用&nbsp;<code>with</code>&nbsp;语句会让你的代码行如踏云，毫无安全感。因为用&nbsp;<code>with</code>&nbsp;添加过来的对象可能会对当前局部作用域的属性与方法产生冲突，进而影响到整个环境。比如，下面的代码发生了什么：</p>
        <div>
<pre class="badcode">with (foo) {
  var x = 3;
  return x;
}</pre>
</div>
        <p>回答: 啥事都可能发生。这个局部变量&nbsp;<code>x</code>&nbsp;可能会被&nbsp;<code>foo</code>&nbsp;对象里的属性所覆盖，它甚至可能会有setter，导致在赋值3时会执行许多其他的代码，所以太危险了，别用&nbsp;<code>with&nbsp;</code>。</p>
      </div>
</div>
    </div>

    <div>
<h3><a id="this" name="this">this</a></h3><span id="link-this__button" class="link_button" name="link-this__button" style="display: none; "><a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml?showone=this">原文</a></span><span id="this__button" class="showhide_button" onclick="javascript:ShowHideByName('this')" name="this__button">▶</span>
      <div style="display: inline;">仅在构造函数，方法，闭包中去使用它。</div><div>
<div style="display: none; " id="this__body" class="stylepoint_body" name="this__body">
        <p><code>this</code>&nbsp;语义很特别。它大多数情况下会指向全局对象，有的时候却是指向调用函数的作用域的（使用eval时），还可能会指向DOM树的某个节点（绑定事件时），新创建的对象（构造函数中），也可能是其他的一些什么乱七八糟的玩意（如果函数被&nbsp;<code>call()<font class="Apple-style-span" color="#333333" face="sans-serif">&nbsp;或者被&nbsp;</font></code><code>apply()&nbsp;</code>）。</p>
        <p>很容易出错的，所以最好是以下这两种情况的时候再选择使用：</p>
        <ul>
          <li>在构造函数中（原型对象）</li>
          <li>在对象的方法中（包括创建的闭包）</li>
        </ul>
      </div>
</div>
    </div>

    <div>
<h3><a id="for-in_loop" name="for-in_loop">for-in 循环</a></h3><span id="link-for-in_loop__button" class="link_button" name="link-for-in_loop__button" style="display: none; "><a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml?showone=for-in_loop">原文</a></span><span id="for-in_loop__button" class="showhide_button" onclick="javascript:ShowHideByName('for-in_loop')" name="for-in_loop__button">▶</span>
      <div style="display: inline;">只在 object/map/hash 要遍历键值的时候使用。</div><div>
<div style="display: none; " id="for-in_loop__body" class="stylepoint_body" name="for-in_loop__body">
        <p><code><span class="Apple-style-span" style="color: rgb(51, 51, 51); font-family: sans-serif; ">对&nbsp;</span><code>Array&nbsp;</code><span class="Apple-style-span" style="color: rgb(51, 51, 51); font-family: sans-serif; ">类型的对象进行&nbsp;</span>for-in</code>&nbsp;循环可能会出错，因为它不是从&nbsp;<code>0</code>&nbsp;到&nbsp;<code>length - 1</code>&nbsp;，而是这个对象包括其原型链上的所有键值，下面是一些失败的例子：</p>
        <div>
<pre class="badcode">function printArray(arr) {
  for (var key in arr) {
    print(arr[key]);
  }
}

printArray([0,1,2,3]);  // 虽然这没问题

var a = new Array(10);
printArray(a);  // 这就错了

a = document.getElementsByTagName('*');
printArray(a);  // 错

a = [0,1,2,3];
a.buhu = 'wine';
printArray(a);  // 错的

a = new Array;
a[3] = 3;
printArray(a);  // 还是错的</pre>
</div>
        <p>遍历数组通常用for就可以了。（译者注：如果木有顺序要求，可以使用for(var i = l;i--;)速度会更高些，但这是10万级效率差，通常是可以被忽略的）</p>
        <div>
<pre>function printArray(arr) {
  var l = arr.length;
  for (var i = 0; i &lt; l; i++) {
    print(arr[i]);
  }
}</pre>
</div>
      </div>
</div>
    </div>

    <div>
<h3>关联数组</h3><span id="link-Associative_Arrays__button" class="link_button" name="link-Associative_Arrays__button" style="display: none; "><a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml?showone=Associative_Arrays">原文</a></span><span id="Associative_Arrays__button" class="showhide_button" onclick="javascript:ShowHideByName('Associative_Arrays')" name="Associative_Arrays__button">▶</span>
      <div style="display: inline;">永远不要用&nbsp;<code>Array</code>&nbsp;去做 map/hash/associative 要做的事情。</div><div>
<div style="display: none; " id="Associative_Arrays__body" class="stylepoint_body" name="Associative_Arrays__body">
        <p>不允许使用关联 <code>Array</code>s ……更具体的说是不允许使用非数字索引的数组（Array不都是用数字索引的么，也没办法用吧除非是两个数组同索引）。如果你需要一个map/hash那就用&nbsp;<code>Object</code>&nbsp;来代替&nbsp;<code>Array</code>&nbsp;吧，实际上你想用的就是&nbsp;<code>Object</code>&nbsp;而不是&nbsp;<code>Array。</code>&nbsp;<code>Array</code>&nbsp;只是继承自&nbsp;<code>Object</code>&nbsp;（和<code>Date</code>,&nbsp;<code>RegExp</code>&nbsp;和&nbsp;<code>String一样</code>）。</p>
      </div>
</div>
    </div>

    <div>
<h3>多行字符串字面量</h3><span id="link-Multiline_string_literals__button" class="link_button" name="link-Multiline_string_literals__button" style="display: none; "><a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml?showone=Multiline_string_literals">原文</a></span><span id="Multiline_string_literals__button" class="showhide_button" onclick="javascript:ShowHideByName('Multiline_string_literals')" name="Multiline_string_literals__button">▶</span>
      不要！<br><div>
<div style="display: none; " id="Multiline_string_literals__body" class="stylepoint_body" name="Multiline_string_literals__body">
        <p>不要这样写：</p>
        <div>
<pre class="badcode">var myString = 'A rather long string of English text, an error message \
                actually that just keeps going and going -- an error \
                message to make the Energizer bunny blush (right through \
                those Schwarzenegger shades)! Where was I? Oh yes, \
                you\'ve got an error and all the extraneous whitespace is \
                just gravy.  Have a nice day.';</pre>
</div>
        <p>空白字符开头字符行不能被很安全的编译剥离，以至于斜杠后面的空格可能会产生奇怪的错误。虽然大多数脚本引擎都支持这个，但它并不是ECMAScript标准的一部分。</p>
        <p>可以用+号运算符来连接每一行：</p>
        <div>
<pre>var myString = 'A rather long string of English text, an error message ' +
    'actually that just keeps going and going -- an error ' +
    'message to make the Energizer bunny blush (right through ' +
    'those Schwarzenegger shades)! Where was I? Oh yes, ' +
    'you\'ve got an error and all the extraneous whitespace is ' +
    'just gravy.  Have a nice day.';</pre>
</div>
      </div>
</div>
    </div>

    <div>
<h3><a id="Array_and_Object_literals" name="Array_and_Object_literals">Array和Object字面量</a></h3><span id="link-Array_and_Object_literals__button" class="link_button" name="link-Array_and_Object_literals__button" style="display: none; "><a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml?showone=Array_and_Object_literals">原文</a></span><span id="Array_and_Object_literals__button" class="showhide_button" onclick="javascript:ShowHideByName('Array_and_Object_literals')" name="Array_and_Object_literals__button">▶</span>
      推荐使用。<br><div>
<div style="display: none; " id="Array_and_Object_literals__body" class="stylepoint_body" name="Array_and_Object_literals__body">
        <p>用&nbsp;<code>Array</code>&nbsp;和&nbsp;<code>Object</code>&nbsp;字面量代替&nbsp;<code>Array</code>&nbsp;和&nbsp;<code>Object</code> 构造函数。</p>
        <p>Array 构造函数会因为传参不当而导致理解错误。</p>
        <div>
<pre class="badcode">// 长度是 3.
var a1 = new Array(x1, x2, x3);

// 长度是 2.
var a2 = new Array(x1, x2);

// 如果x1是自然数那数组的长度就变成了x1
// 如果x1是数字但不是自然数就会报错
// 不然数组就会有一个元素x1
var a3 = new Array(x1);

// 长度是 0.
var a4 = new Array();</pre>
</div>
        <p>如上，如果传入了一个参数而不是两个，那这数组可能就不是预期的长度了。</p>
        <p>为了避免这种情况，用更可读的数组字面量吧。</p>
        <div>
<pre>var a = [x1, x2, x3];
var a2 = [x1, x2];
var a3 = [x1];
var a4 = [];</pre>
</div>
        <p>Object 构造函数没有如上问题，但考虑到可读性和一致性，用字面量更好些。</p>
        <div>
<pre class="badcode">var o = new Object();

var o2 = new Object();
o2.a = 0;
o2.b = 1;
o2.c = 2;
o2['strange key'] = 3;</pre>
</div>
        <p>应该写成：</p>
        <div>
<pre>var o = {};

var o2 = {
  a: 0,
  b: 1,
  c: 2,
  'strange key': 3
};</pre>
</div>
      </div>
</div>
    </div>

    <div>
<h3><a id="Modifying_prototypes_of_builtin_objects" name="Modifying_prototypes_of_builtin_objects">修改内置对象的原型</a></h3><span id="link-Modifying_prototypes_of_builtin_objects__button" class="link_button" name="link-Modifying_prototypes_of_builtin_objects__button" style="display: none; "><a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml?showone=Modifying_prototypes_of_builtin_objects">原文</a></span><span id="Modifying_prototypes_of_builtin_objects__button" class="showhide_button" onclick="javascript:ShowHideByName('Modifying_prototypes_of_builtin_objects')" name="Modifying_prototypes_of_builtin_objects__button">▶</span>
      别这样做。<br><div>
<div style="display: none; " id="Modifying_prototypes_of_builtin_objects__body" class="stylepoint_body" name="Modifying_prototypes_of_builtin_objects__body">
        <p>禁止修改&nbsp;<code>Object.prototype</code> 和          <code>Array.prototype</code>&nbsp;这样的内置对象。可能修改&nbsp;<code>Function.prototype</code>&nbsp;危险性会小些，但它同样会在调试中出现问题，所以尽量避免这样的情况吧。</p>
      </div>
</div>
    </div>

    <div>
<h3><a id="Internet_Explorer_s_Conditional_Comments" name="Internet_Explorer_s_Conditional_Comments">IE下的条件注释</a></h3><span id="link-Internet_Explorer_s_Conditional_Comments__button" class="link_button" name="link-Internet_Explorer_s_Conditional_Comments__button" style="display: none; "><a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml?showone=Internet_Explorer_s_Conditional_Comments">原文</a></span><span id="Internet_Explorer_s_Conditional_Comments__button" class="showhide_button" onclick="javascript:ShowHideByName('Internet_Explorer_s_Conditional_Comments')" name="Internet_Explorer_s_Conditional_Comments__button">▶</span>
      别用。<br><div>
<div style="display: none; " id="Internet_Explorer_s_Conditional_Comments__body" class="stylepoint_body" name="Internet_Explorer_s_Conditional_Comments__body">
        <p>不要这样做：</p>
        <div>
<pre class="badcode">var f = function () {
    /*@cc_on if (@_jscript) { return 2* @*/  3; /*@ } @*/
};</pre>
</div>
        <p>条件注释会妨碍自动化工具的执行，因为他会在运行时改变 JavaScript 语义树。</p>
      </div>
</div>
    </div>
  </div>

  <div>
<h2 id="JavaScript_Style_Rules" name="JavaScript_Style_Rules">JavaScript代码风格规范</h2>
    <div>
<h3><a id="Naming" name="Naming">命名</a></h3><span id="link-Naming__button" class="link_button" name="link-Naming__button" style="display: none; "><a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml?showone=Naming">原文</a></span><span id="Naming__button" class="showhide_button" onclick="javascript:ShowHideByName('Naming')" name="Naming__button">▶</span>
      <div style="display: inline;">
        <p>通常，使用类似于&nbsp;<code>functionNamesLikeThis</code>,
          <code>variableNamesLikeThis</code>, <code>ClassNamesLikeThis</code>,
          <code>EnumNamesLikeThis</code>, <code>methodNamesLikeThis</code>,
          和&nbsp;<code>SYMBOLIC_CONSTANTS_LIKE_THIS&nbsp;</code>这样的命名方式（驼峰式）</p>
      </div>
      <div>
<div style="display: none; " id="Naming__body" class="stylepoint_body" name="Naming__body">
        <p><span class="stylepoint_subsection">属性和方法</span></p><ul>
            <li><i>私有的</i>属性，变量和方法（在文件或类中）都应该改以下划线开头。</li>
            <li><i>受保护的</i>属性，变量和方法不需要用下划线（和公开的一样）。</li>
          </ul>
          <p>更多关于&nbsp;<em>private</em>&nbsp;和&nbsp;<em>protected</em>&nbsp;去看&nbsp;<a href="#Visibility__private_and_protected_fields_">visibility</a>&nbsp;这一部分吧。</p>
        <p></p>

        <p><span class="stylepoint_subsection">方法和函数参数</span></p><p>可选参数以&nbsp;<code>opt_&nbsp;</code>开头。</p>
          <p>函数参数不固定的时候应该有个参数&nbsp;<code>var_args 以</code>数组的形式将参数传进来，也许你不喜欢这样做，那你可以使用&nbsp;<code>arguments</code>&nbsp;这个伪数组。</p>
          <p>可选和可变参数都应该用&nbsp;<code>@param</code>&nbsp;注释标记一下，虽然对解释器都没什么影响，但还是尽量遵守吧，以让代码能够更易理解。</p>
          
        <p></p>

        <p><span class="stylepoint_subsection">&nbsp;属性的</span><span class="Apple-style-span" style="color: rgb(102, 119, 153); font-size: 12px; font-weight: bold; ">访问器</span></p><p>EcmaScript 5 不推荐使用对象属性的 getters 和 setters。你用了就用了吧，但是你得注意，千万别让 getters 方法改变当前对象的各属性状态。</p>
            <div>
<pre class="badcode">/**
 * 错 -- 不要这样做
 */
var foo = { get next() { return this.nextId++; } };
};</pre>
</div>
        <p></p>

        <p><font class="Apple-style-span" color="#667799"><span class="Apple-style-span" style="font-size: 12px; "><b>函数的访问器</b></span></font></p><p>函数对象中的 Getters 和 Setters 也不是必须的。但如果你用了，你最好以类似&nbsp;<code>getFoo()</code> 和
            <code>setFoo(value)</code>.的形式来命名。（如果返回布尔型的值，可以用&nbsp;<code>isFoo()</code>&nbsp;或者其他更自然的名字）</p>
        <p></p>

        <p><span class="stylepoint_subsection">命名空间</span></p><p>JavaScript并不支持包和命名空间。</p>
          <p>这样就导致JS在两个项目以上的集成环境中可能会出现全局作用域下的命名冲突，后果严重且不易调试。为了提高代码的公用性，请大家遵守如下约定以避免冲突。</p>
          <p><span class="stylepoint_subsubsection">在全局作用域下使用伪命名空间</span></p><p>在全局作用域下对相关的JS项目或库用唯一的顶级变量标识当作伪命名空间。比如你的项目名是"Project Sloth"，那可以写一个伪命名空间&nbsp;<code>sloth.*</code>.</p>
            <div>
<pre>var sloth = {};

sloth.sleep = function() {
  ...
};</pre>
</div>
            
            
            <p>好多类似<a href="http://code.google.com/closure/library/">&nbsp;the Closure Library&nbsp;</a>and&nbsp;<a href="http://www.dojotoolkit.org/">Dojo toolkit&nbsp;</a>这样的JS库都会给你一个高阶方法来让你声明命名空间，然后你就可以在这个命名空间下进行各种声明了。</p>
            <div>
<pre>goog.provide('sloth');

sloth.sleep = function() {
  ...
};</pre>
</div>
          <p></p>
          <p><font class="Apple-style-span" color="#667799"><span class="Apple-style-span" style="font-size: 12px;"><b>明确命名空间所有权</b></span></font></p><p>当你选择了一个子命名空间下进行开发，请告知父命名空间的负责人（你懂得）。假设你开始了一个项目是sloths下的hats，请确保这个Sloth项目的负责人知道是你在用<code>sloth.hats。</code></p>
            
          <p></p>
          <p><span class="stylepoint_subsubsection">外部代码和内部代码使用不同的命名空间</span></p><p>“外部代码”指的是你的代码体系以外的可独立编译的代码，比如你用了一个外部库在&nbsp;<code>foo.hats.*&nbsp;</code>下，那你自己的内部代码就不应该再在其下面了，否则会导致产生冲突和难以维护。</p>
            <div>
<pre class="badcode">foo.require('foo.hats');

/**
 * 错 -- 不要这样做
 * @constructor
 * @extend {foo.hats.RoundHat}
 */
foo.hats.BowlerHat = function() {
};</pre>
</div>
            <p>如果你需要在外部命名空间中定义新的API，那你应该通过显式的方法导出公共API函数。自身内部的代码需要使用这些API时，可以直接通过内部命名来调用，一是为了保持一致性，二是能让编译器更好的优化代码。</p>
            <div>
<pre>foo.provide('googleyhats.BowlerHat');

foo.require('foo.hats');

/**
 * @constructor
 * @extend {foo.hats.RoundHat}
 */
googleyhats.BowlerHat = function() {
  ...
};

goog.exportSymbol('foo.hats.BowlerHat', googleyhats.BowlerHat);</pre>
</div>
            
            
          <p></p>
          <p><font class="Apple-style-span" color="#667799"><span class="Apple-style-span" style="font-size: 12px;"><b>为增强可读性，将长名引用化为短别名</b></span></font></p><p>用局部别名引用完整的包名可以增强可读性。局部别名命名应和完整包名的最后一部分相匹配。</p>
            <div>
<pre>/**
 * @constructor
 */
some.long.namespace.MyClass = function() {
};

/**
 * @param {some.long.namespace.MyClass} a
 */
some.long.namespace.MyClass.staticHelper = function(a) {
  ...
};

myapp.main = function() {
  var MyClass = some.long.namespace.MyClass;
  var staticHelper = some.long.namespace.MyClass.staticHelper;
  staticHelper(new MyClass());
};</pre>
</div>
            <p>呃……不要别名引用命名空间。</p>
            <div>
<pre class="badcode">myapp.main = function() {
  var namespace = some.long.namespace;
  namespace.MyClass.staticHelper(new namespace.MyClass());
};</pre>
</div>
            <p>避免访问别名引用对象的属性，除非它是个枚举。</p>
            <div>
<pre>/** @enum {string} */
some.long.namespace.Fruit = {
  APPLE: 'a',
  BANANA: 'b'
};

myapp.main = function() {
  var Fruit = some.long.namespace.Fruit;
  switch (fruit) {
    case Fruit.APPLE:
      ...
    case Fruit.BANANA:
      ...
  }
};</pre>
</div>
            <div>
<pre class="badcode">myapp.main = function() {
  var MyClass = some.long.namespace.MyClass;
  MyClass.staticHelper(null);
};</pre>
</div>
            <p>不要在全局作用域中创建别名引用，仅在函数块中去使用。</p>
          <p></p>
        <p></p>
        <p><span class="stylepoint_subsection">文件名</span>
          </p><p>文件名应该全部字母小写，以避免在某些区分大小写的系统平台产生文件名混淆。文件名应该以&nbsp;<code>.js&nbsp;</code>结束，且不要包含&nbsp;<code>-</code>&nbsp;或&nbsp;<code>_</code>&nbsp;（&nbsp;<code>-</code>&nbsp;比&nbsp;<code>_&nbsp;</code>更好些）。</p>
        <p></p>
        
      </div>
</div>
    </div>

    <div>
<h3><a id="Custom_toString___methods" name="Custom_toString___methods">自定义 toString() 方法</a></h3><span id="link-Custom_toString___methods__button" class="link_button" name="link-Custom_toString___methods__button" style="display: none; "><a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml?showone=Custom_toString___methods">原文</a></span><span id="Custom_toString___methods__button" class="showhide_button" onclick="javascript:ShowHideByName('Custom_toString___methods')" name="Custom_toString___methods__button">▶</span>
      <div style="display: inline;">应该总是成功调用，无副作用。</div><div>
<div style="display: none; " id="Custom_toString___methods__body" class="stylepoint_body" name="Custom_toString___methods__body">
        <p>你可以为自己的对象定义<code>toString()</code>方法。这是好事呀，但是你要确保你的实现方法满足：（1）总是成功的（2）木有副作用。如果你的方法不满足这两个条件，运行起来将会很危险。例如，如果&nbsp;<code>toString()</code>&nbsp;调用了包含&nbsp;<code>assert&nbsp;</code>的方法，&nbsp;<code>assert</code>&nbsp;可能会试着输出失败的对象名，结果又调用了&nbsp;<code>toString()。</code></p>
      </div>
</div>
    </div>

    <div>
<h3><a id="Deferred_initialization" name="Deferred_initialization">延迟初始化</a></h3><span id="link-Deferred_initialization__button" class="link_button" name="link-Deferred_initialization__button" style="display: none; "><a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml?showone=Deferred_initialization">原文</a></span><span id="Deferred_initialization__button" class="showhide_button" onclick="javascript:ShowHideByName('Deferred_initialization')" name="Deferred_initialization__button">▶</span>
      可以。<br><div>
<div style="display: none; " id="Deferred_initialization__body" class="stylepoint_body" name="Deferred_initialization__body">
        <p>没必要总是在声明变量的时候就进行初始化，延迟初始化挺好的。</p>
      </div>
</div>
    </div>

    <div>
<h3><a id="Explicit_scope" name="Explicit_scope">明确作用域</a></h3><span id="link-Explicit_scope__button" class="link_button" name="link-Explicit_scope__button" style="display: none; "><a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml?showone=Explicit_scope">原文</a></span><span id="Explicit_scope__button" class="showhide_button" onclick="javascript:ShowHideByName('Explicit_scope')" name="Explicit_scope__button">▶</span>
      <div style="display: inline;">始终需要明确。</div><div>
<div style="display: none; " id="Explicit_scope__body" class="stylepoint_body" name="Explicit_scope__body">
        <p>任何时候都要明确作用域 - 提高可移植性和清晰度。例如，不要依赖于作用域链中的&nbsp;<code>window</code>&nbsp;对象。有的时候你可能会想让你的其他应用的函数中使用的&nbsp;<code>window</code>&nbsp;对象不是之前所指的窗口对象。</p>
      </div>
</div>
    </div>

    <div>
<h3><a id="Code_formatting" name="Code_formatting">代码格式化</a></h3><span id="link-Code_formatting__button" class="link_button" name="link-Code_formatting__button" style="display: none; "><a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml?showone=Code_formatting">原文</a></span><span id="Code_formatting__button" class="showhide_button" onclick="javascript:ShowHideByName('Code_formatting')" name="Code_formatting__button">▶</span>
      一两句话说不明白，展开了详细讨论<div>
<div style="display: none; " id="Code_formatting__body" class="stylepoint_body" name="Code_formatting__body">
        <p>我们鼓励使用&nbsp;<a href="http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml#Formatting">C++ formatting
          rules</a>&nbsp;里面介绍的代码格式化规范，还有下面要说的：</p>
        <p><font class="Apple-style-span" color="#667799"><span class="Apple-style-span" style="font-size: 12px;"><b>大括号</b></span></font></p><p>因为分号会被隐式插入代码中，所以应将大括号和前面的代码放在一行，以防止误读。例如：</p>
          <div>
<pre>if (something) {
  // ...
} else {

  // ...
}</pre>
</div>
        <p></p>
        <p><span class="stylepoint_subsection">数组和对象的初始化</span></p><p>合适的话，可以直接单行进行数组和元素的初始化：</p>
          <div>
<pre>var arr = [1, 2, 3];  // 前后木有空格
var obj = {a: 1, b: 2, c: 3};  // 前后木有空格</pre>
</div>
          <p>多行数组和元素初始化时，最好缩进两个空格。</p>
          <div>
<pre>// 对象初始化
var inset = {
  top: 10,
  right: 20,
  bottom: 15,
  left: 12
};

// 数组初始化
this.rows_ = [
  '"Slartibartfast" &lt;fjordmaster@magrathea.com&gt;',
  '"Zaphod Beeblebrox" &lt;theprez@universe.gov&gt;',
  '"Ford Prefect" &lt;ford@theguide.com&gt;',
  '"Arthur Dent" &lt;has.no.tea@gmail.com&gt;',
  '"Marvin the Paranoid Android" &lt;marv@googlemail.com&gt;',
  'the.mice@magrathea.com'
];

// 直接在方法中调用
goog.dom.createDom(goog.dom.TagName.DIV, {
  id: 'foo',
  className: 'some-css-class',
  style: 'display:none'
}, 'Hello, world!');</pre>
</div>
          <p>在初始化列表中如果碰到了比较长的属性名或值，不要为了觉得让代码好看些而手工对齐，比如：</p>
          <div>
<pre>CORRECT_Object.prototype = {
  a: 0,
  b: 1,
  lengthyName: 2
};</pre>
</div>
          <p>只有屌丝才这样做：</p>
          <div>
<pre class="badcode">WRONG_Object.prototype = {
  a          : 0,
  b          : 1,0
  lengthyName: 2
};</pre>
</div>
        <p></p>
        <p><span class="stylepoint_subsection">函数参数</span></p><p>尽可能的将所有的函数参数都写在同一行上，但为了保持增强可读性，如果一行超过了80字符的话可适当的换行，甚至可以每个参数都独立一行，记得格式上的优化，比如缩进4个空格和对齐括号。</p><p>以下是几种常见的：</p>
          <div>
<pre>// Four-space, wrap at 80.  Works with very long function names, survives
// renaming without reindenting, low on space.
goog.foo.bar.doThingThatIsVeryDifficultToExplain = function(
    veryDescriptiveArgumentNumberOne, veryDescriptiveArgumentTwo,
    tableModelEventHandlerProxy, artichokeDescriptorAdapterIterator) {
  // ...
};

// Four-space, one argument per line.  Works with long function names,
// survives renaming, and emphasizes each argument.
goog.foo.bar.doThingThatIsVeryDifficultToExplain = function(
    veryDescriptiveArgumentNumberOne,
    veryDescriptiveArgumentTwo,
    tableModelEventHandlerProxy,
    artichokeDescriptorAdapterIterator) {
  // ...
};

// Parenthesis-aligned indentation, wrap at 80.  Visually groups arguments,
// low on space.
function foo(veryDescriptiveArgumentNumberOne, veryDescriptiveArgumentTwo,
             tableModelEventHandlerProxy, artichokeDescriptorAdapterIterator) {
  // ...
}

// Parenthesis-aligned, one argument per line.  Visually groups and
// emphasizes each individual argument.
function bar(veryDescriptiveArgumentNumberOne,
             veryDescriptiveArgumentTwo,
             tableModelEventHandlerProxy,
             artichokeDescriptorAdapterIterator) {
  // ...
}</pre>
</div>
          <p>如果调用的函数本身就已经缩进了，呃你当然可以针对于当前被调用的函数（或之前的原始函数）再向前缩进4个空格。以下这样的风格勉强可以接受：</p>
          <div>
<pre>if (veryLongFunctionNameA(
        veryLongArgumentName) ||
    veryLongFunctionNameB(
    veryLongArgumentName)) {
  veryLongFunctionNameC(veryLongFunctionNameD(
      veryLongFunctioNameE(
          veryLongFunctionNameF)));
}</pre>
</div>
        <p></p>
        <p><font class="Apple-style-span" color="#667799"><span class="Apple-style-span" style="font-size: 12px;"><b>传递匿名函数</b></span></font></p><p>如果调用方法传参内有匿名函数的声明，函数体应相对于该调用方法（或变量名）缩进2个空格，这样匿名函数体更易阅读（而不是将代码挤到屏幕的另一半）。</p>
          <div>
<pre>prefix.something.reallyLongFunctionName('whatever', function(a1, a2) {
  if (a1.equals(a2)) {
    someOtherLongFunctionName(a1);
  } else {
    andNowForSomethingCompletelyDifferent(a2.parrot);
  }
});

var names = prefix.something.myExcellentMapFunction(
    verboselyNamedCollectionOfItems,
    function(item) {
      return item.name;
    });</pre>
</div>
        <p></p>
        <p><b style="color: rgb(102, 119, 153); font-size: 12px; ">男子汉的缩进是可以突破天际的！</b></p><p>事实上，除了<a href="#Array_and_Object_literals">数组和元素的初始化</a>和传递匿名方法以外，都应哦该相对于上一行表达式的左对齐缩进4个空格，而不是2个。</p>

          <div>
<pre>someWonderfulHtml = '' +
                    getEvenMoreHtml(someReallyInterestingValues, moreValues,
                                    evenMoreParams, 'a duck', true, 72,
                                    slightlyMoreMonkeys(0xfff)) +
                    '';

thisIsAVeryLongVariableName =
    hereIsAnEvenLongerOtherFunctionNameThatWillNotFitOnPrevLine();

thisIsAVeryLongVariableName = 'expressionPartOne' + someMethodThatIsLong() +
    thisIsAnEvenLongerOtherFunctionNameThatCannotBeIndentedMore();

someValue = this.foo(
    shortArg,
    'Some really long string arg - this is a pretty common case, actually.',
    shorty2,
    this.bar());

if (searchableCollection(allYourStuff).contains(theStuffYouWant) &amp;&amp;
    !ambientNotification.isActive() &amp;&amp; (client.isAmbientSupported() ||
                                        client.alwaysTryAmbientAnyways())) {
  ambientNotification.activate();
}</pre>
</div>
        <p></p>
        <p><font class="Apple-style-span" color="#667799"><span class="Apple-style-span" style="font-size: 12px; "><b>空行</b></span></font></p><p>用空行划分一组逻辑上相关的代码，例如：</p>
          <div>
<pre>doSomethingTo(x);
doSomethingElseTo(x);
andThen(x);

nowDoSomethingWith(y);

andNowWith(z);</pre>
</div>
        <p></p>
        <p><font class="Apple-style-span" color="#667799"><span class="Apple-style-span" style="font-size: 12px;"><b>二元和三元操作符</b></span></font></p><p>操作符始终放在前行，这样就不用顾虑分号的隐式插入的问题，如果一行放不下，可以参考本节函数参数的写法。</p>
          <div>
<pre>var x = a ? b : c;  // 能放一行的都放在一行里

// 缩进4个空格木有问题
var y = a ?
    longButSimpleOperandB : longButSimpleOperandC;

// 缩进到第一个判断变量位置木有问题
var z = a ?
        moreComplicatedB :
        moreComplicatedC;</pre>
</div>
        <p></p>
      </div>
</div>
    </div>

    <div>
<h3><a id="Parentheses" name="Parentheses">括号</a></h3><span id="link-Parentheses__button" class="link_button" name="link-Parentheses__button" style="display: none; "><a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml?showone=Parentheses">原文</a></span><span id="Parentheses__button" class="showhide_button" onclick="javascript:ShowHideByName('Parentheses')" name="Parentheses__button">▶</span>
      <div style="display: inline;">只在需要的时候使用。</div><div>
<div style="display: none; " id="Parentheses__body" class="stylepoint_body" name="Parentheses__body">
        <p>括号的事情可大可小，没必要的时候不要用它。</p>
        <p>对于一元操作符（如&nbsp;<code>delete</code>, <code>typeof</code>&nbsp;和&nbsp;<code>void）</code>或是某些关键字（如<code>return</code>, <code>throw</code>,&nbsp;<code>case</code>,&nbsp;<code>new）后面永远不要使用括号。</code></p>
      </div>
</div>
    </div>

    <div>
<h3><a id="Strings" name="Strings">字符串</a></h3><span id="link-Strings__button" class="link_button" name="link-Strings__button" style="display: none; "><a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml?showone=Strings">原文</a></span><span id="Strings__button" class="showhide_button" onclick="javascript:ShowHideByName('Strings')" name="Strings__button">▶</span>
      <div style="display: inline;">单引号（'）比双引号（"）更好。</div><div>
<div style="display: none; " id="Strings__body" class="stylepoint_body" name="Strings__body">
        <p>使用单引号（'）比双引号（"）更好，特别是当创建一个HTML代码的字符串时候：</p>
        <div>
<pre>var msg = 'This is some HTML';</pre>
</div>
      </div>
</div>
    </div>

    <div>
<h3><a id="Visibility__private_and_protected_fields_" name="Visibility__private_and_protected_fields_">可见性（私有和受保护的字段）</a></h3><span id="link-Visibility__private_and_protected_fields___button" class="link_button" name="link-Visibility__private_and_protected_fields___button" style="display: none; "><a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml?showone=Visibility__private_and_protected_fields_">原文</a></span><span id="Visibility__private_and_protected_fields___button" class="showhide_button" onclick="javascript:ShowHideByName('Visibility__private_and_protected_fields_')" name="Visibility__private_and_protected_fields___button">▶</span>
      <div style="display: inline;">鼓励使用JSDoc中的&nbsp;<code>@private</code>&nbsp;和&nbsp;<code>@protected&nbsp;</code></div>进行标注。<div>
<div style="display: none; " id="Visibility__private_and_protected_fields___body" class="stylepoint_body" name="Visibility__private_and_protected_fields___body">
        <p>我们推荐使用JSDoc的&nbsp;<code>@private</code>&nbsp;和&nbsp;<code>@protected</code>&nbsp;对类，函数和属性进行可见性权限的标注。</p>
        <p>有个写做 --jscomp_warning=visibility 的编译器参数，编辑器会提示违反可见性相关的警告。具体内容请查看<a href="http://code.google.com/p/closure-compiler/wiki/Warnings">&nbsp;Closure Compiler
          Warnings</a>.
        </p>
        <p><code><span class="Apple-style-span" style="color: rgb(51, 51, 51); font-family: sans-serif; ">标注为&nbsp;</span>@private</code>&nbsp;的全局变量和函数，只有其自身文件中的代码能进行访问和调用。</p>
        <p>构造函数标注了&nbsp;<code>@private</code>&nbsp;则代表着只能在自身文件中使用它的公共静态方法或实例化，也可以通过&nbsp;<code>instanceof</code>&nbsp;操作符进行访问。</p>
        <p>永远不要为全局变量，函数和构造函数标记&nbsp;<code>@protected&nbsp;</code>。</p>
        <div>
<pre>// 文件 1。
// AA_PrivateClass_ 和 AA_init_ 可以相互访问，因为他们在同一个文件里。

/**
 * @private
 * @constructor
 */
AA_PrivateClass_ = function() {
};

/** @private */
function AA_init_() {
  return new AA_PrivateClass_();
}

AA_init_();</pre>
</div>
        <p><code><span class="Apple-style-span" style="color: rgb(51, 51, 51); font-family: sans-serif; ">标记&nbsp;</span>@private</code>&nbsp;的属性，自身文件内的代码可以访问，如果这个属性是某个类的，那此类的所有静态方法和实例方法也是都可以访问的。 但来自不同文件的子类是无法访问或重载该属性的。</p>
        <p><code><font class="Apple-style-span" color="#333333" face="sans-serif">标记&nbsp;</font>@protected</code>&nbsp;的属性，自身文件内的代码可以访问，如果这个属性是属于某个类的，那此类包括子类的所有静态方法和实例方法都可以访问。</p>
        <p>注意,这些语义不同于C++和Java，它们允许在同一文件中访问私有和受保护的属性，而不只是限制在同一个类或类继承中。而且，不向在C++中，私有属性是不能被子类重载的。</p>
        <div>
<pre>// File 1.

/** @constructor */
  AA_PublicClass = function() {
};

/** @private */
AA_PublicClass.staticPrivateProp_ = 1;

/** @private */
AA_PublicClass.prototype.privateProp_ = 2;

/** @protected */
AA_PublicClass.staticProtectedProp = 31;

/** @protected */
AA_PublicClass.prototype.protectedProp = 4;

// File 2.

/**
 * @return {number} The number of ducks we've arranged in a row.
 */
AA_PublicClass.prototype.method = function() {
  // Legal accesses of these two properties.
  return this.privateProp_ + AA_PublicClass.staticPrivateProp_;
};

// File 3.

/**
 * @constructor
 * @extends {AA_PublicClass}
 */
AA_SubClass = function() {
  // Legal access of a protected static property.
  AA_PublicClass.staticProtectedProp = this.method();
};
goog.inherits(AA_SubClass, AA_PublicClass);

/**
 * @return {number} The number of ducks we've arranged in a row.
 */
AA_SubClass.prototype.method = function() {
  // Legal access of a protected instance property.
  return this.protectedProp;
};</pre>
</div>

        <p>再注意，在JavaScript中，子类(如&nbsp;<code>AA_PrivateClass_</code>)和该类的原型类的可见性是相同的，没有办法实现两个子类是公共的，而他们的构造函数却是私有（因为构造函数很容易别名）。</p>
      </div>
</div>
    </div>

    <div>
<h3><a id="JavaScript_Types" name="JavaScript_Types">JavaScript类型</a></h3><span id="link-JavaScript_Types__button" class="link_button" name="link-JavaScript_Types__button" style="display: none; "><a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml?showone=JavaScript_Types">原文</a></span><span id="JavaScript_Types__button" class="showhide_button" onclick="javascript:ShowHideByName('JavaScript_Types')" name="JavaScript_Types__button">▶</span>
      <div style="display: inline;">强烈建议使用编译器。</div><div>
<div style="display: none; " id="JavaScript_Types__body" class="stylepoint_body" name="JavaScript_Types__body">
        <p>如果使用JSDoc，那就尽量按照它的规范去写，目前支持&nbsp;<a href="http://wiki.ecmascript.org/doku.php?id=spec:spec">JS2
</a>&nbsp;和&nbsp;JS1.x 两种规范。</p><p>（译者表示表格里的单词太多，要犯懒，想了解详细信息的可以查阅<a href="http://wiki.ecmascript.org/doku.php?id=spec:spec">JS2</a>）</p>
        <p><span class="stylepoint_subsection">JavaScript类型语言</span></p><p>这个JS2提议为JavaScript类型定制了一种语言。当我们在JsDoc中注释函数参数和返回值类型的时候会用到它。</p>

          <p>虽然JS2提议在不断的进化，但编译器还是会继续支持老的类型语法，只是不建议使用而已。</p>

          <p></p>
          <table style="border-collapse: collapse;" border="1" cellpadding="4">
            
              <tbody><tr>
                <th>Operator Name</th>
                <th>Syntax</th>
                <th>Description</th>
                <th>Deprecated Syntaxes</th>
              </tr>
            
            
              <tr>
                <td>Type Name</td>
                <td>
                  <code>{boolean}</code>, <code>{Window}</code>,
                  <code>{goog.ui.Menu}</code>
                </td>
                <td>Simply the name of a type.</td>
                <td></td>
              </tr>

              <tr>
                <td>Type Application</td>
                <td>
                  <code>{Array.&lt;string&gt;}</code><br>An array of strings.<p></p>
                  <code>{Object.&lt;string, number&gt;}</code>
                  <br>An object in which the keys are strings and the values
                  are numbers.
                </td>
                <td>Patameterizes a type, by applying a set of type arguments
                  to that type. The idea is analogous to generics in Java.
                </td>
                <td></td>
              </tr>

              <tr>
                <td>Type Union</td>
                <td>
                  <code>{(number|boolean)}</code><br>A number or a boolean.
                </td>
                <td>Indicates that a value might have type A OR type B.</td>
                <td>
                  <code>{(number,boolean)}</code>,
                  <code>{number|boolean}</code>,
                  <code>{(number||boolean)}</code>
                </td>
              </tr>

              <tr>
                <td>Record Type</td>
                <td>
                  <code>{{myNum: number, myObject}}</code>
                  <br>An anonymous type with the given type members.
                </td>
                <td>
                  <p>Indicates that the value has the specified members with the
                    specified types. In this case, <code>myNum</code> with a
                    type <code>number</code> and <code>myObject</code> with any
                    type.</p>
                  <p>Notice that the braces are part of the type syntax. For
                    example, to denote an <code>Array</code> of objects that
                    have a <code>length</code> property, you might write
                  <code>Array.&lt;{length}&gt;</code>.</p>
                </td>
                <td></td>
              </tr>

              <tr>
                <td>Nullable type</td>
                <td>
                  <code>{?number}</code><br> A number or NULL.
                </td>
                <td>Indicates that a value is type A or <code>null</code>.
                  By default, all object types are nullable.
                  NOTE: Function types are not nullable.
                </td>
                <td>
                  <code>{number?}</code>
                </td>
              </tr>

              <tr>
                <td>Non-nullable type</td>
                <td>
                  <code>{!Object}</code><br> An Object, but never the
                  <code>null</code> value.
                </td>
                <td>Indicates that a value is type A and not null. By default,
                  all value types (boolean, number, string, and undefined) are
                  not nullable.
                </td>
                <td>
                  <code>{Object!}</code>
                </td>
              </tr>

              <tr>
                <td>Function Type</td>
                <td>
                  <code>{function(string, boolean)}</code><br>
                  A function that takes two arguments (a string and a boolean),
                  and has an unknown return value.<br>
                </td>
                <td>Specifies a function.</td>
                <td></td>
              </tr>

              <tr>
                <td>Function Return Type</td>
                <td>
                  <code>{function(): number}</code><br>
                  A function that takes no arguments and returns a number.<br>
                </td>
                <td>Specifies a function return type.</td>
                <td></td>
              </tr>

              <tr>
                <td>Function <code>this</code> Type</td>
                <td>
                  <code>{function(this:goog.ui.Menu, string)}</code><br>
                  A function that takes one argument (a string), and executes
                  in the context of a goog.ui.Menu.
                </td>
                <td>Specifies the context type of a function type.</td>
                <td></td>
              </tr>

              <tr>
                <td>Function <code>new</code> Type</td>
                <td>
                  <code>{function(new:goog.ui.Menu, string)}</code><br>
                  A constructor that takes one argument (a string), and
                  creates a new instance of goog.ui.Menu when called
                  with the 'new' keyword.
                </td>
                <td>Specifies the constructed type of a constructor.</td>
                <td></td>
              </tr>

              <tr>
                <td>Variable arguments</td>
                <td>
                  <code>{function(string, ...[number]): number}</code><br>
                  A function that takes one argument (a string), and then a
                  variable number of arguments that must be numbers.
                </td>
                <td>Specifies variable arguments to a function.</td>
                <td></td>
              </tr>

              <tr>
                <td>
                  <a name="var-args-annotation"></a>
                  Variable arguments (in <code>@param</code> annotations)
                </td>
                <td>
                  <code>@param {...number} var_args</code><br>
                  A variable number of arguments to an annotated function.
                </td>
                <td>
                  Specifies that the annotated function accepts a variable
                  number of arguments.
                </td>
                <td></td>
              </tr>

              <tr>
                <td>Function <a href="optional">optional arguments</a></td>
                <td>
                  <code>{function(?string=, number=)}</code><br>
                  A function that takes one optional, nullable string and one
                  optional number as arguments. The <code>=</code> syntax is
                  only for <code>function</code> type declarations.
                </td>
                <td>Specifies optional arguments to a function.</td>
                <td></td>
              </tr>

              <tr>
                <td>
                  <a name="optional-arg-annotation"></a>
                  Function <a href="optional">optional arguments</a>
                  (in <code>@param</code> annotations)
                </td>
                <td>
                  <code>@param {number=} opt_argument</code><br>
                  An optional parameter of type <code>number</code>.
                </td>
                <td>Specifies that the annotated function accepts an optional
                  argument.</td>
                <td></td>
              </tr>

              <tr>
                <td>The ALL type</td>
                <td><code>{*}</code></td>
                <td>Indicates that the variable can take on any type.</td>
                <td></td>
              </tr>

              <tr>
                <td>The UNKNOWN type</td>
                <td><code>{?}</code></td>
                <td>Indicates that the variable can take on any type,
                    and the compiler should not type-check any uses of it.</td>
                <td></td>
              </tr>
            
          </tbody></table>
        <p></p>
        <p><span class="stylepoint_subsection">JavaScript的对象类型</span></p><p></p>
          <table style="border-collapse: collapse;" border="1" cellpadding="4">
            
              <tbody><tr>
                <th>类型示例</th>
                <th>只示例</th>
                <th>描述</th>
              </tr>
            
            

              <tr>
                <td>number</td>
                <td>
                  <div>
<pre>1
1.0
-5
1e5
Math.PI</pre>
</div>
                </td>
                <td>数字，整型，浮点型，科学计算型，数字常量</td>
              </tr>

              <tr>
                <td>Number</td>
                <td>
                  <div>
<pre>new Number(true)</pre>
</div>
                </td>
                <td>
                  <a href="#Wrapper_objects_for_primitive_types">
                    Number 对象</a></td>
              </tr>

              <tr>
                <td>string</td>
                <td>
                  <div>
<pre>'Hello'
"World"
String(42)</pre>
</div>
                </td>
                <td>字符串值</td>
              </tr>

              <tr>
                <td>String</td>
                <td>
                  <div>
<pre>new String('Hello')
new String(42)</pre>
</div>
                </td>
                <td>
                  <a href="#Wrapper_objects_for_primitive_types">
                    String 对象</a></td>
              </tr>

              <tr>
                <td>boolean</td>
                <td>
                  <div>
<pre>true
false
Boolean(0)</pre>
</div>
                </td>
                <td>布尔值</td>
              </tr>

              <tr>
                <td>Boolean</td>
                <td>
                  <div>
<pre>new Boolean(true)</pre>
</div>
                </td>
                <td>
                  <a href="#Wrapper_objects_for_primitive_types">
                    Boolean 对象</a></td>
              </tr>

              <tr>
                <td>RegExp</td>
                <td>
                  <div>
<pre>new RegExp('hello')
/world/g</pre>
</div>
</td>
<td>正则表达式</td>
              </tr>

              <tr>
                <td>Date</td>
                <td>
                  <div>
<pre>new Date
new Date()</pre>
</div>
</td>
                <td>日期</td>
              </tr>

              <tr>
                <td>
                  
                  null
                  
                </td>
                <td>
                  <div>
<pre>null</pre>
</div>
                </td>
                <td><br></td>
              </tr>

              <tr>
                <td>
                  
                  undefined
                  
                </td>
                <td>
                  <div>
<pre>undefined</pre>
</div>
                </td>
                <td></td>
              </tr>

              <tr>
                <td>void</td>
                <td>
                  <div>
<pre>function f() {
  return;
}</pre>
</div>
                </td>
                <td>返回undefined</td>
              </tr>

              <tr>
                <td>Array</td>
                <td>
                  <div>
<pre>['foo', 0.3, null]
[]</pre>
</div>
                </td>
                <td>混型数组</td>
              </tr>

              <tr>
                <td>Array.&lt;number&gt;</td>
                <td>
                  <div>
<pre>[11, 22, 33]</pre>
</div>
                </td>
                <td>数字型数组</td>
              </tr>

              <tr>
                <td>Array.&lt;Array.&lt;string&gt;&gt;</td>
                <td>
                  <div>
<pre>[['one', 'two', 'three'], ['foo', 'bar']]</pre>
</div>
                </td>
                <td>字符串型数组嵌套数组</td>
              </tr>

              <tr>
                <td>Object</td>
                <td>
                  <div>
<pre>{}
{foo: 'abc', bar: 123, baz: null}</pre>
</div>
                </td>
                <td>对象表达式</td>
              </tr>

              <tr>
                <td>Object.&lt;string&gt;</td>
                <td>
                  <div>
<pre>{'foo': 'bar'}</pre>
</div>
                </td>
                <td>一个对象，键和值都是字符串。</td>
              </tr>

              <tr>
                <td>Object.&lt;number, string&gt;</td>
                <td>
                  <div>
<pre>var obj = {};
obj[1] = 'bar';</pre>
</div>
                </td>
                <td>一个对象，键是数字，值是字符串。<br><p></p>注意，在JavaScript中，对象的键总是会被隐式的转换成字符串，所以<code>obj['1'] == obj[1]</code>。所以键总是以一个字符串的形式在for...in循环中，但如果键在索引时，编译器会验证类型。</td>
              </tr>

              <tr>
                <td>Function</td>
                <td>
                  <div>
<pre>function(x, y) {
  return x * y;
}</pre>
</div>
                </td>
                <td>
                  <a href="#Wrapper_objects_for_primitive_types">
                    Function 对象
                  </a>
                </td>
              </tr>

              <tr>
                <td>function(number, number): number</td>
                <td>
                  <div>
<pre>function(x, y) {
  return x * y;
}</pre>
</div>
                </td>
                <td>函数值</td>
              </tr>

              <tr>
                <td><a name="constructor-tag">SomeClass</a></td>
                <td>
                  <div>
<pre>/** @constructor */
function SomeClass() {}

new SomeClass();</pre>
</div>
                </td>
                <td>伪类 -&nbsp;类实例</td>
              </tr>

              <tr>
                <td>SomeInterface</td>
                <td>
                  <div>
<pre>/** @interface */
function SomeInterface() {}

SomeInterface.prototype.draw = function() {};</pre>
</div>
                </td>
                <td>原型类</td>
              </tr>

              <tr>
                <td>project.MyClass</td>
                <td>
                  <div>
<pre>/** @constructor */
project.MyClass = function () {}

new project.MyClass()</pre>
</div>
                </td>
                <td>构造内部类 - 内部类实例</td>
              </tr>

              <tr>
                <td>project.MyEnum</td>
                <td>
                  <div>
<pre>/** @enum {string} */
project.MyEnum = {
  BLUE: '#0000dd',
  RED: '#dd0000'
};</pre>
</div>
                </td>
                <td><a href="#enums">枚举</a></td>
              </tr>

              <tr>
                <td>Element</td>
                <td>
                  <div>
<pre>document.createElement('div')</pre>
</div>
                </td>
                <td>在DOM中创建一个元素节点</td>
              </tr>

              <tr>
                <td>Node</td>
                <td>
                  <div>
<pre>document.body.firstChild</pre>
</div>
                </td>
                <td>返回在DOM中的节点body的第一个子节点</td>
              </tr>

              <tr>
                <td>HTMLInputElement</td>
                <td>
                  <div>
<pre>htmlDocument.getElementsByTagName('input')[0]</pre>
</div>
                </td>
                <td>查找一组特定标签类型的DOM元素，返回第一个</td>
              </tr>
            
          </tbody></table>
        <p></p>

        <p><font class="Apple-style-span" color="#667799"><span class="Apple-style-span" style="font-size: 12px;"><b>明确类型</b></span></font></p><p>可能出现类型检查并不能准确判断表达式的类型的情况，可以在注释里添加类型标注，并在中括号内写出表达式的类型，如果有对该类型的注解就更好了。</p>

          <div>
<pre>/** @type {number} */ (x)
(/** @type {number} */ x)</pre>
</div>
        <p></p>

        <p><span class="stylepoint_subsection">可空 vs.可选的参数和属性</span><a name="optional"></a></p><p>因为JavaScript是弱类型的语言，理解函数参数和类属性的可选，可空与未定义之间的区别还是很重要的。</p>

          <p>对象类型（也称引用类型）默认是可空的，注意：函数类型默认非空。除了字符串，数字，布尔，undefined或null以外，对象可以是任何类型。例如：</p>

          <div>
<pre>/**
 * Some class, initialized with a value.
 * @param {Object} value Some value.
 * @constructor
 */
function MyClass(value) {
  /**
   * Some value.
   * @type {Object}
   * @private
   */
  this.myValue_ = value;
}</pre>
</div>

          <p>上段代码是告诉编译器&nbsp;<code>myValue_</code>&nbsp;属性为一个对象或null。如果&nbsp;<code>myValue_</code>&nbsp;永远也不能是null，那就应该像下面一样声明：</p>

          <div>
<pre>/**
 * Some class, initialized with a non-null value.
 * @param {!Object} value Some value.
 * @constructor
 */
function MyClass(value) {
  /**
   * Some value.
   * @type {!Object}
   * @private
   */
  this.myValue_ = value;
}</pre>
</div>

          <p>这样，如果编译器在代码中碰到&nbsp;<code>MyClass</code>&nbsp;初始化个null值是，就会发出警告。</p>

          

          <p>函数的可选参数可能在运行的时候并没有被定义，如果参数引用至类的属性上，那则需要如下声明：</p>

          <div>
<pre>/**
 * Some class, initialized with an optional value.
 * @param {Object=} opt_value Some value (optional).
 * @constructor
 */
function MyClass(opt_value) {
  /**
   * Some value.
   * @type {Object|undefined}
   * @private
   */
  this.myValue_ = opt_value;
}</pre>
</div>

          <p>以上代码是告诉编译器说&nbsp;<code>myValue_</code>&nbsp;有可能是一个对象，null，还可能是 undefined。</p>

          <p>注意：可选参数&nbsp;<code>opt_value</code>&nbsp;被声明为&nbsp;<code>{Object=}</code>，而并不是&nbsp;<code>{Object|undefined}</code>。这是因为可选属性可能是定义的或未定义的，虽然说明确写undefined也没关系，但读起来前边的更爽。</p>

          <p>最后，注意可空和可选都是正交属性，下面的四个声明都是不同的：</p>

          <div>
<pre>/**
 * Takes four arguments, two of which are nullable, and two of which are
 * optional.
 * @param {!Object} nonNull Mandatory (must not be undefined), must not be null.
 * @param {Object} mayBeNull Mandatory (must not be undefined), may be null.
 * @param {!Object=} opt_nonNull Optional (may be undefined), but if present,
 *     must not be null!
 * @param {Object=} opt_mayBeNull Optional (may be undefined), may be null.
 */
function strangeButTrue(nonNull, mayBeNull, opt_nonNull, opt_mayBeNull) {
  // ...
};</pre>
</div>
        <p></p>

        <p><span class="stylepoint_subsection">类型定义</span><a name="Typedefs"></a></p><p>类型定义也可以复杂化，一个函数可以接受元素节点的内容：</p>

          <div>
<pre>/**
 * @param {string} tagName
 * @param {(string|Element|Text|Array.&lt;Element&gt;|Array.&lt;Text&gt;)} contents
 * @return {!Element}
 */
goog.createElement = function(tagName, contents) {
  ...
};</pre>
</div>

          <p>你可以定义&nbsp;<code>@typedef</code>&nbsp;标记的常用类型表达式，例如：</p>

          <div>
<pre>/** @typedef {(string|Element|Text|Array.&lt;Element&gt;|Array.&lt;Text&gt;)} */
goog.ElementContent;

/**
 * @param {string} tagName
 * @param {goog.ElementContent} contents
 * @return {!Element}
 */
goog.createElement = function(tagName, contents) {
...
};</pre>
</div>
        <p></p>

        <p><font class="Apple-style-span" color="#667799"><span class="Apple-style-span" style="font-size: 12px;"><b>模板属性</b></span></font></p><p>编译器已经有限的支持模板类型。它只能推断的类型,这在一个匿名函数字面量从类型的这个论点,是否这个论点是缺失的。The compiler has limited support for template types. It can only
            infer the type of <code>this</code> inside an anonymous function
            literal from the type of the <code>this</code> argument and whether the
            <code>this</code> argument is missing.</p>

          <div>
<pre>/**
 * @param {function(this:T, ...)} fn
 * @param {T} thisObj
 * @param {...*} var_args
 * @template T
 */
goog.bind = function(fn, thisObj, var_args) {
...
};
// Possibly generates a missing property warning.
goog.bind(function() { this.someProperty; }, new SomeClass());
// Generates an undefined this warning.
goog.bind(function() { this.someProperty; });</pre>
</div>
        <p></p>
      </div>
</div>
    </div>

    <div>
<h3><a name="Comments" id="Comments">注释</a></h3><span id="link-Comments__button" class="link_button" name="link-Comments__button" style="display: none; "><a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml?showone=Comments">原文</a></span><span id="Comments__button" class="showhide_button" onclick="javascript:ShowHideByName('Comments')" name="Comments__button">▶</span>
      <div style="display: inline;">使用 JSDoc</div>
      <div>
<div style="display: none; " id="Comments__body" class="stylepoint_body" name="Comments__body">
        <p>我们鼓励依照&nbsp;<a href="http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml#Comments">C++ style for comments&nbsp;</a>的风格。</p>

        <p>所有的文件，类，方法和属性都应该以&nbsp;<a href="http://code.google.com/p/jsdoc-toolkit/">JSDoc</a>&nbsp;风格来进行注释。</p>

        <p>行内注释使用&nbsp;<code>//</code>&nbsp;。</p>

        <p>避免出现句式片段，如果是英文首字母大写，记得加标点符号。</p>

        <p><font class="Apple-style-span" color="#667799"><span class="Apple-style-span" style="font-size: 12px; "><b>注释语法</b></span></font></p><p>JSDoc的语法基于<a href="http://www.oracle.com/technetwork/java/javase/documentation/index-137868.html">JavaDoc
</a>。&nbsp;许多工具可以从JSDoc注释中提取元数据来执行代码的验证和优化。当然，前提是这些注释都是符合语法规则的。</p>

          <div>
<pre>/**
 * A JSDoc comment should begin with a slash and 2 asterisks.
 * Inline tags should be enclosed in braces like {@code this}.
 * @desc Block tags should always start on their own line.
 */</pre>
</div>
        <p></p>

        <p><span class="stylepoint_subsection">JSDoc 缩进</span></p><p>如果你不得不换行块标签，那就应该缩进四个空格以保持注释内容的结构清晰。</p>

          <div>
<pre>/**
 * Illustrates line wrapping for long param/return descriptions.
 * @param {string} foo This is a param with a description too long to fit in
 *     one line.
 * @return {number} This returns something that has a description too long to
 *     fit in one line.
 */
project.MyClass.prototype.method = function(foo) {
  return 5;
};</pre>
</div>

          <p>你不应该缩进&nbsp;<code>@fileoverview</code>&nbsp;命令。</p>

          <p>尽管缩进至与上排注释同列并不怎么好，但也是可以接受的。</p>

          <div>
<pre>/**
 * This is NOT the preferred indentation method.
 * @param {string} foo This is a param with a description too long to fit in
 *                     one line.
 * @return {number} This returns something that has a description too long to
 *                  fit in one line.
 */
project.MyClass.prototype.method = function(foo) {
  return 5;
};</pre>
</div>
        <p></p>

        <p><span class="stylepoint_subsection">JSDoc的</span><span class="Apple-style-span" style="color: rgb(102, 119, 153); font-size: 12px; font-weight: bold; ">HTML</span></p><p>就像JavaDoc一样，JSDoc支持好多HTML标签，如 &lt;code&gt;,
            &lt;pre&gt;, &lt;tt&gt;, &lt;strong&gt;, &lt;ul&gt;, &lt;ol&gt;,
            &lt;li&gt;, &lt;a&gt;等等。</p>

          <p>昂所以纯文本状态并不会被格式化，比如换行和空格什么的都会被忽略掉：</p>

          <div>
<pre class="badcode">/**
 * Computes weight based on three factors:
 *   items sent
 *   items received
 *   last timestamp
 */</pre>
</div>

          <p>上面的结果其实是：</p>

          <div>
<pre class="badcode">Computes weight based on three factors: items sent items received items received</pre>
</div>

          <p>所以，可以用这种方式：</p>

          <div>
<pre>/**
 * Computes weight based on three factors:
 * &lt;ul&gt;
 * &lt;li&gt;items sent
 * &lt;li&gt;items received
 * &lt;li&gt;last timestamp
 * &lt;/ul&gt;
 */</pre>
</div>关于写注释更多信息可以去看一下&nbsp;<a href="http://www.oracle.com/technetwork/java/javase/documentation/index-137868.html">JavaDoc</a>&nbsp;风格指南。<p></p>

        <p><span class="stylepoint_subsection">顶部或文件头的注释</span></p><p>顶部注释是为了让读者能够很快的明了这个文件里的代码是干嘛的，描述应包括作者，年代，依赖关系或兼容信息等相关，下面的例子：</p>

          <div>
<pre>// Copyright 2009 Google Inc. All Rights Reserved.

/**
 * @fileoverview Description of file, its uses and information
 * about its dependencies.
 * @author user@google.com (Firstname Lastname)
 */</pre>
</div>

          
        <p></p>

        <p><span class="stylepoint_subsection">类的注释</span></p><p>对于类的注释，肯定要写功能和类型的描述，还有一些参数和原型描述等信息。</p>

          <div>
<pre>/**
 * Class making something fun and easy.
 * @param {string} arg1 An argument that makes this more interesting.
 * @param {Array.&lt;number&gt;} arg2 List of numbers to be processed.
 * @constructor
 * @extends {goog.Disposable}
 */
project.MyClass = function(arg1, arg2) {
  // ...
};
goog.inherits(project.MyClass, goog.Disposable);</pre>
</div>
        <p></p>

        <p><span class="stylepoint_subsection">方法和函数的注释</span></p><p>应该有参数和返回值的描述，方法描述要以使用者的身份去写。</p>
          <div>
<pre>/**
 * Operates on an instance of MyClass and returns something.
 * @param {project.MyClass} obj Instance of MyClass which leads to a long
 *     comment that needs to be wrapped to two lines.
 * @return {boolean} Whether something occured.
 */
function PR_someMethod(obj) {
  // ...
}</pre>
</div>

          <p>一些简单的get方法没有参数和其他影响的，可以忽略描述。</p>
        <p></p>

        <p><span class="stylepoint_subsection">属性的描述</span></p><div>
<pre>/**
 * Maximum number of things per pane.
 * @type {number}
 */
project.MyClass.prototype.someProperty = 4;</pre>
</div>
        <p></p>

        <p><span class="stylepoint_subsection">JSDoc标签参考</span></p>
        <p>（译者注：看到解释有一大段，译者犯懒，有想看的请查阅&nbsp;<a href="http://code.google.com/p/jsdoc-toolkit/wiki/TagReference">JSDoc Toolkit Tag Reference&nbsp;</a>）</p>
        <p></p>
          <table border="1" style="border-collapse:collapse" cellpadding="4">
            
              <tbody><tr>
                <th>Tag</th>
                <th>Template &amp; Examples</th>
                <th>Description</th>
              </tr>
            
            
              <tr>
                <td>
                  <a name="tag-author">@author</a>
                  
                </td>
                <td>
                  <code>@author username@google.com (first last)</code>
                  <p><i>For example:</i></p>
                  <div class=""><pre>/**
 * @fileoverview Utilities for handling textareas.
 * @author kuth@google.com (Uthur Pendragon)
 */</pre></div>
                </td>
                <td>
                  Document the author of a file or the owner of a test,
                  generally only used in the <code>@fileoverview</code> comment.
                  
                </td>
              </tr>

              

              <tr>
                <td><a name="tag-code">@code</a></td>
                <td>
                  <code>{@code ...}</code>
                  <p><i>For example:</i></p>
                  <div class=""><pre>/**
 * Moves to the next position in the selection.
 * Throws {@code goog.iter.StopIteration} when it
 * passes the end of the range.
 * @return {Node} The node at the next position.
 */
goog.dom.RangeIterator.prototype.next = function() {
  // ...
};</pre></div>
                </td>
                <td>
                  Indicates that a term in a JSDoc description is code so it may
                  be correctly formatted in generated documentation.
                </td>
              </tr>

              <tr>
                <td><a name="tag-const">@const</a></td>
                <td>
                  <code>@const</code>
                  <p><i>For example:</i></p>
                  <div class=""><pre>/** @const */ var MY_BEER = 'stout';

/**
 * My namespace's favorite kind of beer.
 * @const
 * @type {string}
 */
mynamespace.MY_BEER = 'stout';

/** @const */ MyClass.MY_BEER = 'stout';</pre></div>
                </td>
                <td>
                  <p>Marks a variable as read-only and suitable for inlining.
                    Generates warnings if it is rewritten.</p>
                  <p>Constants should also be ALL_CAPS, but the annotation
                    should help eliminate reliance on the naming convention.
                    Although @final is listed at jsdoc.org and is supported as
                    equivalent to @const in the compiler, it is discouraged.
                    @const is consistent with JS1.5's const keyword. Note that
                    changes to properties of const objects are not currently
                    prohibited by the compiler (inconsistent with C++ const
                    semantics). The type declaration can be omitted if it can be
                    clearly inferred. If present, it must be on its own line. An
                    additional comment about the variable is optional.</p>
                </td>
              </tr>

              <tr>
                <td><a name="tag-constructor">@constructor</a></td>
                <td>
                  <code>@constructor</code>
                  <p><i>For example:</i></p>
                  <div class=""><pre>/**
 * A rectangle.
 * @constructor
 */
function GM_Rect() {
  ...
}</pre></div>
                </td>
                <td>
                  Used in a class's documentation to indicate the constructor.
                </td>
              </tr>

              <tr>
                <td><a name="tag-define">@define</a></td>
                <td>
                  <code>@define {Type} description</code>
                  <p><i>For example:</i></p>
                  <div class=""><pre>/** @define {boolean} */
var TR_FLAGS_ENABLE_DEBUG = true;

/** @define {boolean} */
goog.userAgent.ASSUME_IE = false;</pre></div>
                </td>
                <td>
                  Indicates a constant that can be overridden by the compiler at
                  compile-time. In the example, the compiler flag
                  <code>--define='goog.userAgent.ASSUME_IE=true'</code>
                  could be specified in the BUILD file to indicate that the
                  constant <code>goog.userAgent.ASSUME_IE</code> should be replaced
                  with <code>true</code>.
                </td>
              </tr>

              <tr>
                <td><a name="tag-deprecated">@deprecated</a></td>
                <td>
                  <code>@deprecated Description</code>
                  <p><i>For example:</i></p>
                  <div class=""><pre>/**
 * Determines whether a node is a field.
 * @return {boolean} True if the contents of
 *     the element are editable, but the element
 *     itself is not.
 * @deprecated Use isField().
 */
BN_EditUtil.isTopEditableField = function(node) {
  // ...
};</pre></div>
                </td>
                <td>
                  Used to tell that a function, method or property should not be
                  used any more.  Always provide instructions on what callers
                  should use instead.
                </td>
              </tr>

              <tr>
                <td><a name="tag-enum">@enum</a></td>
                <td>
                  <code>@enum {Type}</code>
                  <p><i>For example:</i></p>
                  <div class=""><pre>/**
 * Enum for tri-state values.
 * @enum {number}
 */
project.TriState = {
  TRUE: 1,
  FALSE: -1,
  MAYBE: 0
};</pre></div>
                </td>
              </tr>

              <tr>
                <td><a name="tag-export">@export</a></td>
                <td>
                  <code>@export</code>
                  <p><i>For example:</i></p>
                  <div class=""><pre>/** @export */
foo.MyPublicClass.prototype.myPublicMethod = function() {
  // ...
};</pre></div>
                </td>
                <td>
                  <p>Given the code on the left, when the compiler is run with
                  the <code>--generate_exports</code> flag, it will generate the
                  code:</p>
                  <div class=""><pre>goog.exportSymbol('foo.MyPublicClass.prototype.myPublicMethod',
    foo.MyPublicClass.prototype.myPublicMethod);</pre></div>
                  <p>which will export the symbols to uncompiled code.
                  Code that uses the <code>@export</code> annotation must either</p>
                  <ol>
                    <li>include <code>//javascript/closure/base.js</code>, or</li>
                    <li>define both <code>goog.exportSymbol</code> and
                      <code>goog.exportProperty</code> with the same method
                      signature in their own codebase.</li>
                  </ol>
                </td>
              </tr>

              <tr>
                <td><a name="tag-extends">@extends</a></td>
                <td>
                  <code>
                    @extends Type<br>
                    @extends {Type}
                  </code>
                  <p><i>For example:</i></p>
                  <div class=""><pre>/**
 * Immutable empty node list.
 * @constructor
 * @extends goog.ds.BasicNodeList
 */
goog.ds.EmptyNodeList = function() {
  ...
};</pre></div>
                </td>
                <td>
                  Used with @constructor to indicate that a class inherits from
                  another class. Curly braces around the type are optional.
                </td>
              </tr>

              <tr>
                <td><a name="tag-externs">@externs</a></td>
                <td>
                  <code>@externs</code>
                  <p><i>For example:</i></p>
                  <div class=""><pre>/**
 * @fileoverview This is an externs file.
 * @externs
 */

var document;</pre></div>
                </td>
                <td>
                  <p>
                    Declares an
                    
                    externs file.
                  </p>

                  
                </td>
              </tr>

              <tr>
                <td><a name="tag-fileoverview">@fileoverview</a></td>
                <td>
                  <code>@fileoverview Description</code>
                  <p><i>For example:</i></p>
                  <div class=""><pre>/**
 * @fileoverview Utilities for doing things that require this very long
 * but not indented comment.
 * @author kuth@google.com (Uthur Pendragon)
 */</pre></div>
                </td>
                <td>Makes the comment block provide file level information.</td>
              </tr>

              <tr>
                <td><a name="tag-implements">@implements</a></td>
                <td>
                  <code>
                    @implements Type<br>
                    @implements {Type}
                  </code>
                  <p><i>For example:</i></p>
                  <div class=""><pre>/**
 * A shape.
 * @interface
 */
function Shape() {};
Shape.prototype.draw = function() {};

/**
 * @constructor
 * @implements {Shape}
 */
function Square() {};
Square.prototype.draw = function() {
  ...
};</pre></div>
                </td>
                <td>
                  Used with @constructor to indicate that a class implements an
                  interface. Curly braces around the type are optional.
                </td>
              </tr>

              <tr>
                <td><a name="tag-inheritDoc">@inheritDoc</a></td>
                <td>
                  <code>@inheritDoc</code>
                  <p><i>For example:</i></p>
                  <div class=""><pre>/** @inheritDoc */
project.SubClass.prototype.toString() {
  // ...
};</pre></div>
                </td>
                <td>
                  <p style="font-weight:bold">Deprecated. Use @override
                  instead.</p>

                  Indicates that a method or property of a subclass
                  intentionally hides a method or property of the superclass,
                  and has exactly the same documentation. Notice that
                  @inheritDoc implies @override.
                </td>
              </tr>

              <tr>
                <td><a name="tag-interface">@interface</a></td>
                <td>
                  <code>@interface</code>
                  <p><i>For example:</i></p>
                  <div class=""><pre>/**
 * A shape.
 * @interface
 */
function Shape() {};
Shape.prototype.draw = function() {};

/**
 * A polygon.
 * @interface
 * @extends {Shape}
 */
function Polygon() {};
Polygon.prototype.getSides = function() {};</pre></div>
                </td>
                <td>Used to indicate that the function defines an inteface.</td>
              </tr>

              <tr>
                <td><a name="tag-lends">@lends</a></td>
                <td>
                  <code>@lends objectName</code><br>
                  <code>@lends {objectName}</code>
                  <p><i>For example:</i></p>
                  <div class=""><pre>goog.object.extend(
    Button.prototype,
    /** @lends {Button.prototype} */ {
      isButton: function() { return true; }
    });</pre></div>
                </td>
                <td>
                  Indicates that the keys of an object literal should
                  be treated as properties of some other object. This annotation
                  should only appear on object literals.<p></p>

                  Notice that the name in braces is not a type name like
                  in other annotations. It's an object name. It names
                  the object on which the properties are "lent".
                  For example, <code>@type {Foo}</code> means "an instance of Foo",
                  but <code>@lends {Foo}</code> means "the constructor Foo".<p></p>

                  The <a href="http://code.google.com/p/jsdoc-toolkit/wiki/TagLends">
                  JSDoc Toolkit docs</a> have more information on this
                  annotation.
                </td>
              </tr>

              <tr>
                <td>
<a name="tag-license">@license</a> or
                  <a name="tag-preserve">@preserve</a>
</td>
                <td>
                  <code>@license Description</code>
                  <p><i>For example:</i></p>
                  <div class=""><pre>/**
 * @preserve Copyright 2009 SomeThirdParty.
 * Here is the full license text and copyright
 * notice for this file. Note that the notice can span several
 * lines and is only terminated by the closing star and slash:
 */</pre></div>
                </td>
                <td>
                  Anything marked by @license or @preserve will be retained by
                  the compiler and output at the top of the compiled code for
                  that file. This annotation allows important notices (such as
                  legal licenses or copyright text) to survive compilation
                  unchanged. Line breaks are preserved.
                </td>
              </tr>

              <tr>
                <td><a name="tag-noalias">@noalias</a></td>
                <td>
                  <code>@noalias</code>
                  <p><i>For example:</i></p>
                  <div class=""><pre>/** @noalias */
function Range() {}</pre></div>
                </td>
                <td>
                  Used in an externs file to indicate to the compiler that the
                  variable or function should not be aliased as part of the
                  alias externals pass of the compiler.
                </td>
              </tr>

              <tr>
                <td><a name="tag-nosideeffects">@nosideeffects</a></td>
                <td>
                  <code>@nosideeffects</code>
                  <p><i>For example:</i></p>
                  <div class=""><pre>/** @nosideeffects */
function noSideEffectsFn1() {
  // ...
};

/** @nosideeffects */
var noSideEffectsFn2 = function() {
  // ...
};

/** @nosideeffects */
a.prototype.noSideEffectsFn3 = function() {
  // ...
};</pre></div>
                </td>
                <td>
                  This annotation can be used as part of function and
                  constructor declarations to indicate that calls to the
                  declared function have no side-effects.  This annotation
                  allows the compiler to remove calls to these functions if the
                  return value is not used.
                </td>
              </tr>

              <tr>
                <td><a name="tag-override">@override</a></td>
                <td>
                  <code>@override</code>
                  <p><i>For example:</i></p>
                  <div class=""><pre>/**
 * @return {string} Human-readable representation of project.SubClass.
 * @override
 */
project.SubClass.prototype.toString() {
  // ...
};</pre></div>
                </td>
                <td>
                  Indicates that a method or property of a subclass
                  intentionally hides a method or property of the superclass. If
                  no other documentation is included, the method or property
                  also inherits documentation from its superclass.
                </td>
              </tr>

              <tr>
                <td><a name="tag-param">@param</a></td>
                <td>
                  <code>@param {Type} varname Description</code>
                  <p><i>For example:</i></p>
                  <div class=""><pre>/**
 * Queries a Baz for items.
 * @param {number} groupNum Subgroup id to query.
 * @param {string|number|null} term An itemName,
 *     or itemId, or null to search everything.
 */
goog.Baz.prototype.query = function(groupNum, term) {
  // ...
};</pre></div>
                </td>
                <td>
                  Used with method, function and constructor calls to document
                  the arguments of a function.<p></p>

                  Type names must be enclosed in curly braces. If the type
                  is omitted, the compiler will not type-check the parameter.
                </td>
              </tr>

              <tr>
                <td><a name="tag-private">@private</a></td>
                <td>
                  <code>@private</code>
                  <p><i>For example:</i></p>
                  <div class=""><pre>/**
 * Handlers that are listening to this logger.
 * @type Array.&lt;Function&gt;
 * @private
 */
this.handlers_ = [];</pre></div>
                </td>
                <td>
                  Used in conjunction with a trailing underscore on the method
                  or property name to indicate that the member is
                  <a href="#Visibility__private_and_protected_fields_">private</a>.
                  Trailing underscores may eventually be deprecated as tools are
                  updated to enforce <code>@private</code>.
                </td>
              </tr>

              <tr>
                <td><a name="tag-protected">@protected</a></td>
                <td>
                  <code>@protected</code>
                  <p><i>For example:</i></p>
                  <div class=""><pre>/**
 * Sets the component's root element to the given element.  Considered
 * protected and final.
 * @param {Element} element Root element for the component.
 * @protected
 */
goog.ui.Component.prototype.setElementInternal = function(element) {
  // ...
};</pre></div>
                </td>
                <td>
                  Used to indicate that the member or property is
                  <a href="#Visibility__private_and_protected_fields_">protected</a>.
                  Should be used in conjunction with names with no trailing
                  underscore.
                </td>
              </tr>

              <tr>
                <td><a name="tag-return">@return</a></td>
                <td>
                  <code>@return {Type} Description</code>
                  <p><i>For example:</i></p>
                  <div class=""><pre>/**
 * @return {string} The hex ID of the last item.
 */
goog.Baz.prototype.getLastId = function() {
  // ...
  return id;
};</pre></div>
                </td>
                <td>
                  Used with method and function calls to document the return
                  type.  When writing descriptions for boolean parameters,
                  prefer "Whether the component is visible" to "True if the
                  component is visible, false otherwise". If there is no return
                  value, do not use an <code>@return</code> tag.<p></p>

                  Type names must be enclosed in curly braces. If the type
                  is omitted, the compiler will not type-check the return value.
                </td>
              </tr>

              <tr>
                <td><a name="tag-see">@see</a></td>
                <td>
                  <code>@see Link</code>
                  <p><i>For example:</i></p>
                  <div class=""><pre>/**
 * Adds a single item, recklessly.
 * @see #addSafely
 * @see goog.Collect
 * @see goog.RecklessAdder#add
 ...</pre></div>
                </td>
                <td>Reference a lookup to another class function or method.</td>
              </tr>

              <tr>
                <td><a name="tag-supported">@supported</a></td>
                <td>
                  <code>@supported Description</code>
                  <p><i>For example:</i></p>
                  <div class=""><pre>/**
 * @fileoverview Event Manager
 * Provides an abstracted interface to the
 * browsers' event systems.
 * @supported So far tested in IE6 and FF1.5
 */</pre></div>
                </td>
                <td>
                  Used in a fileoverview to indicate what browsers are supported
                  by the file.
                </td>
              </tr>

              <tr>
                <td><a name="tag-suppress">@suppress</a></td>
                <td>
                  <code>
                    @suppress {warning1|warning2}
                  </code>
                  <p><i>For example:</i></p>
                  <div class=""><pre>/**
 * @suppress {deprecation}
 */
function f() {
  deprecatedVersionOfF();
}</pre></div>
                </td>
                <td>
                  Suppresses warnings from tools. Warning categories are
                  separated by <code>|</code>.
                </td>
              </tr>

              <tr>
                <td><a name="tag-template">@template</a></td>
                <td>
                  <code>@template</code>
                  <p><i>For example:</i></p>
                  <div class=""><pre>/**
 * @param {function(this:T, ...)} fn
 * @param {T} thisObj
 * @param {...*} var_args
 * @template T
 */
goog.bind = function(fn, thisObj, var_args) {
...
};</pre></div>
                </td>
                <td>
                  This annotation can be used to declare a
                  <a href="#Template_types">template typename</a>.
                </td>
              </tr>

              <tr>
                <td><a name="tag-this">@this</a></td>
                <td>
                  <code>
                    @this Type<br>
                    @this {Type}
                  </code>
                  <p><i>For example:</i></p>
                  <div class=""><pre>pinto.chat.RosterWidget.extern('getRosterElement',
/**
 * Returns the roster widget element.
 * @this pinto.chat.RosterWidget
 * @return {Element}
 */
function() {
  return this.getWrappedComponent_().getElement();
});</pre></div>
                </td>
                <td>
                  The type of the object in whose context a particular method is
                  called. Required when the <code>this</code> keyword is referenced
                  from a function that is not a prototype method.
                </td>
              </tr>

              <tr>
                <td><a name="tag-type">@type</a></td>
                <td>
                  <code>
                    @type Type<br>
                    @type {Type}
                  </code>
                  <p><i>For example:</i></p>
                  <div class=""><pre>/**
 * The message hex ID.
 * @type {string}
 */
var hexId = hexId;</pre></div>
                </td>
                <td>
                  Identifies the type of a variable, property, or expression.
                  Curly braces are not required around most types, but some
                  projects mandate them for all types, for consistency.
                </td>
              </tr>

              <tr>
                <td><a name="tag-typedef">@typedef</a></td>
                <td>
                  <code>@typedef</code>
                  <p><i>For example:</i></p>
                  <div class=""><pre>/** @typedef {(string|number)} */
goog.NumberLike;

/** @param {goog.NumberLike} x A number or a string. */
goog.readNumber = function(x) {
  ...
}</pre></div>
                </td>
                <td>
                  This annotation can be used to declare an alias of a more
                  <a href="#Typedefs">complex type</a>.
                </td>
              </tr>
            
          </tbody></table>

          <p>推荐使用的有：</p><p>@typedef @type @this @template @suppress @supported @see @return @protected @private @param @override @nosideeffects @noalias @lends @interface @inheritDoc @implements @fileoverview @externs @extends @export @enum @deprecated @define @constructor @const @code</p><p>你可能在第三方代码中看到其他的JSDoc标注。昂它们在Google代码中并不怎么鼓励使用，但谁知道呢可能未来的某一天就突然的用起来了呢，先看看吧：</p><ul>
              <li>@augments</li>
              <li>@argument</li>
              <li>@borrows</li>
              <li>@class</li>
              <li>@constant</li>
              <li>@constructs</li>
              <li>@default</li>
              <li>@event</li>
              <li>@example</li>
              <li>@field</li>
              <li>@function</li>
              <li>@ignore</li>
              <li>@inner</li>
              <li>@link</li>
              <li>@memberOf</li>
              <li>@name</li>
              <li>@namespace</li>
              <li>@property</li>
              <li>@public</li>
              <li>@requires</li>
              <li>@returns</li>
              <li>@since</li>
              <li>@static</li>
              <li>@version</li>
            </ul>
          <p></p>
        <p></p>
      </div>
</div>
    </div>

    <div>
<h3><a name="Inner_Classes_and_Enums" id="Inner_Classes_and_Enums">内部类和枚举</a></h3><span id="link-Inner_Classes_and_Enums__button" class="link_button" name="link-Inner_Classes_and_Enums__button" style="display: none; "><a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml?showone=Inner_Classes_and_Enums">原文</a></span><span id="Inner_Classes_and_Enums__button" class="showhide_button" onclick="javascript:ShowHideByName('Inner_Classes_and_Enums')" name="Inner_Classes_and_Enums__button">▶</span>内部类和枚举的定义应和顶级类放在同一文件内。<br><div><div style="display: none; " class="stylepoint_body" name="Inner_Classes_and_Enums__body" id="Inner_Classes_and_Enums__body">内部类和枚举的定义都应和顶级类在同一文件内。<code>goog.provide</code>（google库的方法，主要功能是注册类和方法声明）</div>只需要声明顶级类。</div>
    </div>

    <div>
<h3><a name="Compiling" id="Compiling">编译压缩</a></h3><span id="link-Compiling__button" class="link_button" name="link-Compiling__button" style="display: none; "><a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml?showone=Compiling">原文</a></span><span id="Compiling__button" class="showhide_button" onclick="javascript:ShowHideByName('Compiling')" name="Compiling__button">▶</span>
      推荐使用。<br><div>
<div style="display: none; " id="Compiling__body" class="stylepoint_body" name="Compiling__body">
        

        <p>使用被编译压缩后的JS代码可以更快下载和使用，咳咳，工具的话google推荐&nbsp;<a href="http://code.google.com/closure/compiler/">Closure Compiler</a>。</p>

        

        
      </div>
</div>
    </div>

    <div>
<h3><a name="Tips_and_Tricks" id="Tips_and_Tricks">提示和技巧</a></h3><span id="link-Tips_and_Tricks__button" class="link_button" name="link-Tips_and_Tricks__button" style="display: none; "><a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml?showone=Tips_and_Tricks">原文</a></span><span id="Tips_and_Tricks__button" class="showhide_button" onclick="javascript:ShowHideByName('Tips_and_Tricks')" name="Tips_and_Tricks__button">▶</span>
      <div style="display: inline;">JavaScript 习习更健康。</div><div>
<div style="display: none; " id="Tips_and_Tricks__body" class="stylepoint_body" name="Tips_and_Tricks__body">
        <p><span class="stylepoint_subsection">True 和 False 布尔表达式</span></p><p>以下的表达式都返回false：</p>
          <ul>
            <li><code>null</code></li>
            <li><code>undefined</code></li>
            <li><code>''</code> 空字符串</li>
            <li><code>0</code>&nbsp;数字0</li>
          </ul>
          <p>小心咯，以下的都返回true：</p>
          <ul>
            <li><code>'0'</code> 字符串0</li>
            <li><code>[]</code>&nbsp;空数组</li>
            <li><code>{}</code> 空对象</li>
          </ul>

          <p>你可能会写下面这段代码：</p>
          <div>
<pre class="badcode">while (x != null) {</pre>
</div>
          <p>其实还可以写的更短些（只要你也不希望x是0、空字符串和false）：</p>
          <div>
<pre>while (x) {</pre>
</div>

          <p>如果想检查字符串是否为null或空，你可能会这样写：</p>
          <div>
<pre class="badcode">if (y != null &amp;&amp; y != '') {</pre>
</div>
          <p>当然可以写的更短些：</p>
          <div>
<pre>if (y) {</pre>
</div>

          <p>注意: 还有很多非直观的布尔表达式，如下：</p>
          <ul>
            <li><code>
              Boolean('0') == true<br>
              '0' != true</code></li>
            <li><code>
              0 != null<br>
              0 == []<br>
              0 == false</code></li>
            <li><code>
              Boolean(null) == false<br>
              null != true<br>
              null != false</code></li>
            <li><code>
              Boolean(undefined) == false<br>
              undefined != true<br>
              undefined != false</code></li>
            <li><code>
              Boolean([]) == true<br>
              [] != true<br>
              [] == false (经验证无错，译者表示困惑，难道这里是按照length去判断的么)</code></li>
            <li><code>
              Boolean({}) == true<br>
              {} != true<br>
              {} != false</code></li>
          </ul>
        <p></p>

        <p><span class="stylepoint_subsection">条件（三元）操作符(?:)</span>
          </p><p>下面这段代码可以被三元操作符所替换：</p>
          <div>
<pre>if (val != 0) {
  return foo();
} else {
  return bar();
}</pre>
</div>
          <p>你可以写成：</p>
          <div>
<pre>return val ? foo() : bar();</pre>
</div>

          <p>在生成HTML的时候也很有用噢：</p>
          <div>
<pre>var html = '&lt;input type="checkbox"' +
    (isChecked ? ' checked' : '') +
    (isEnabled ? '' : ' disabled') +
    ' name="foo"&gt;';</pre>
</div>
        <p></p>

        <p><span class="stylepoint_subsection">&amp;&amp; 和 ||</span>
          </p><p>这俩二元布尔操作符可以根据前面的代码判断后面的代码是否执行，也就是说只有在必要的时候才会执行后面的代码。</p>

          <p>"||" 可以被称为默认操作符，因为它可以代替下面的情况：</p>
          <div>
<pre class="badcode">/** @param {*=} opt_win */
function foo(opt_win) {
  var win;
  if (opt_win) {
    win = opt_win;
  } else {
    win = window;
  }
  // ...
}</pre>
</div>
          <p>其实你可以直接写：</p>
          <div>
<pre>/** @param {*=} opt_win */
function foo(opt_win) {
  var win = opt_win || window;
  // ...
}</pre>
</div>

          <p>"&amp;&amp;" 也可以缩减代码量，比如：</p>
          <div>
<pre class="badcode">if (node) {
  if (node.kids) {
    if (node.kids[index]) {
      foo(node.kids[index]);
    }
  }
}</pre>
</div>

          <p>可以写成：</p>
          <div>
<pre>if (node &amp;&amp; node.kids &amp;&amp; node.kids[index]) {
  foo(node.kids[index]);
}</pre>
</div>

          <p>或者写成：</p>
          <div>
<pre>var kid = node &amp;&amp; node.kids &amp;&amp; node.kids[index];
if (kid) {
  foo(kid);
}</pre>
</div>

          <p>但如果这样的话就有点过了：</p>
          <div>
<pre class="badcode">node &amp;&amp; node.kids &amp;&amp; node.kids[index] &amp;&amp; foo(node.kids[index]);</pre>
</div>
        <p></p>

        <p><span class="stylepoint_subsection">用join()构建字符串</span></p><p>构建字符串通常都是这样的：</p>
          <div>
<pre class="badcode">function listHtml(items) {
  var html = '&lt;div class="foo"&gt;';
  for (var i = 0; i &lt; items.length; ++i) {
    if (i &gt; 0) {
      html += ', ';
    }
    html += itemHtml(items[i]);
  }
  html += '&lt;/div&gt;';
  return html;
}</pre>
</div>

          <p>但上面这种方式在IE下面是很没效率的，更好的方式是：</p>
          <div>
<pre>function listHtml(items) {
  var html = [];
  for (var i = 0; i &lt; items.length; ++i) {
    html[i] = itemHtml(items[i]);
  }
  return '&lt;div class="foo"&gt;' + html.join(', ') + '&lt;/div&gt;';
}</pre>
</div>

          <p>你也可以用数组做字符串拼接，然后用&nbsp;<code>myArray.join('')&nbsp;</code>转换成字符串，但要注意给数组赋值分配快于用&nbsp;<code>push()</code>&nbsp;，你最好使用赋值的方式。</p>
        <p></p>

        <p><span class="stylepoint_subsection">遍历节点列表</span></p><p>节点列表是通过节点迭代器和一个过滤器来实现的，这表示它的一个属性例如length的时间复杂度是O(n)，通过length来遍历整个列表则需要O(n^2)。</p>
          <div>
<pre class="badcode">var paragraphs = document.getElementsByTagName('p');
for (var i = 0; i &lt; paragraphs.length; i++) {
  doSomething(paragraphs[i]);
}</pre>
</div>

          <p>这样写会更好些：</p>
          <div>
<pre>var paragraphs = document.getElementsByTagName('p');
for (var i = 0, paragraph; paragraph = paragraphs[i]; i++) {
  doSomething(paragraph);
}</pre>
</div>

          <p>这种方式对所有集合和数组都适用，当然只要里面没有布尔值false。</p>

          <p>你也可以通过 firstChild 和 nextSibling 属性来遍历子节点。</p>
          <div>
<pre>var parentNode = document.getElementById('foo');
for (var child = parentNode.firstChild; child; child = child.nextSibling) {
  doSomething(child);
}</pre>
</div>
        <p></p>
      </div>
</div>
    </div>
  </div>

  

  <h2>吐槽部分</h2>
    <p>
      <em>坚持一致原则</em>。</p>

    <p>如果你要编辑代码，先花几分钟看看它的代码风格，如果它这么做，那你也应该这么做。</p>

    <p>风格统一了，就有了一个共同思维的环境，参与者就可以专注的看你要说什么，而不是先想你是在说哪星球的语言。 虽然我们在这里提出统一样式规则，但就只是想让大家都知晓并借鉴而对自己的风格进行修正。 当然，保持自己独有的风格也是很重要的。balabala……</p>

  

  <p align="right">
    修正版本 2.28
  </p>

  <address>
    译者：chajn<br>
    新浪微博：<a target="_blank" href="http://weibo.com/chajn">@chajn</a><br>
    于 2012-05-18<br>
    那个苦逼的下午<br>
    特别感谢<a target="_blank" href="http://weibo.com/27855136">@教主</a> <a target="_blank" href="http://weibo.com/206103888">@三水清</a> <a target="_blank" href="http://weibo.com/buxiaodewa">@不晓得V</a>给予的技术支持<br>
  </address>








<span id="tongji1"><iframe height="0" src="http://img.users.51.la/6036471.asp" width="0"></iframe></span><span id="tongji3"><iframe height="0" src="http://img.users.51.la/6940293.asp" width="0"></iframe></span></body></html>